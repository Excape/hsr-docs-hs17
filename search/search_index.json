{
    "docs": [
        {
            "location": "/", 
            "text": "HSR Notizen\n\n\nFall Semester '17\n\n\n\n\nProgrammiersprachen und formale Methoden\n\n\nProjekt- und Qualit\u00e4tsmanagement\n\n\nApplication Architecture\n\n\nAdvanced Patterns and Frameworks\n\n\n\n\nLinks\n\n\n\n\nMathJax Syntax\n\n\nMkDocs User-Guide\n\n\nMarkdown Cheatsheet", 
            "title": "Home"
        }, 
        {
            "location": "/#hsr-notizen", 
            "text": "", 
            "title": "HSR Notizen"
        }, 
        {
            "location": "/#fall-semester-17", 
            "text": "Programmiersprachen und formale Methoden  Projekt- und Qualit\u00e4tsmanagement  Application Architecture  Advanced Patterns and Frameworks", 
            "title": "Fall Semester '17"
        }, 
        {
            "location": "/#links", 
            "text": "MathJax Syntax  MkDocs User-Guide  Markdown Cheatsheet", 
            "title": "Links"
        }, 
        {
            "location": "/playground/", 
            "text": "Markdown Playground\n\n\nDies ist etwas normaler Text mit etwas \nkursiver\n schrift und etwas \nbold\n schrift\n\n\nDieser Text ist \nmarkiert\n, hier sind emojis: \n \n \n\n\n\n\n1\n2\nDies ist Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text\nzweite Zeile\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n  \npublic\n \nclass\n \nTestClass\n()\n \n{\n\n    \nint\n \nvar\n \n=\n \n1\n;\n\n\n    \npublic\n \nmethod\n()\n \n{\n\n\n      \nreturn\n \nvar\n;\n\n\n    \n}\n\n\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2\n\n\n3\n\n\n\n\n\n\n\n\n\n\n1\n\n\netwas\n\n\nanderes\n\n\n\n\n\n\n2\n\n\nals\n\n\nhier\n\n\n\n\n\n\n\n\n\n\nNotiz\n\n\nTest Notiz mit etwas Text drin\n\n\n\n\nNote\nKlapp mich auf!\n\n\nDanger\n\n\nGefahr!\n\n\n\n\n\n\nWarning\n\n\nWarnung!\n\n\n\n\n\n\nSummary\n\n\nEine Zusammenfassung\n\n\n\n\n\n\nInfo\n\n\nEine Information\n\n\n\n\n\n\nTip\n\n\nEin Tip\n\n\n\n\n\n\nQuestion\n\n\nEine Frage\n\n\n\n\n\n\nBug\n\n\nEin Bug\n\n\n\n\n\n\nQuote\n\n\nEin Zitat\n\n\n\n\nInline Math: \n x_i^2 * \\frac{(n^2 * n) - 1}{\\Omega} \n\n\n\n\nDisplay Math:\n\n\\sum_{i=0}^n i^2\n\n\n\n\nGruppen mit \n{}\n: \n{10}^5\n\n\n\n\n\n\nA \\rightarrow B \n\n\n\\lim_{x\\to \\infty} \\sin x", 
            "title": "Playground"
        }, 
        {
            "location": "/playground/#markdown-playground", 
            "text": "Dies ist etwas normaler Text mit etwas  kursiver  schrift und etwas  bold  schrift  Dieser Text ist  markiert , hier sind emojis:        1\n2 Dies ist Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text ein Text\nzweite Zeile   1\n2\n3\n4\n5\n6    public   class   TestClass ()   { \n     int   var   =   1 ;       public   method ()   {         return   var ;       }     }       1  2  3      1  etwas  anderes    2  als  hier      Notiz  Test Notiz mit etwas Text drin   Note Klapp mich auf!  Danger  Gefahr!    Warning  Warnung!    Summary  Eine Zusammenfassung    Info  Eine Information    Tip  Ein Tip    Question  Eine Frage    Bug  Ein Bug    Quote  Ein Zitat   Inline Math:   x_i^2 * \\frac{(n^2 * n) - 1}{\\Omega}    Display Math: \\sum_{i=0}^n i^2   Gruppen mit  {} :  {10}^5    A \\rightarrow B   \\lim_{x\\to \\infty} \\sin x", 
            "title": "Markdown Playground"
        }, 
        {
            "location": "/prfm/", 
            "text": "Programmiersprachen und formale Methoden\n\n\n\n\nIntroduction", 
            "title": "Index"
        }, 
        {
            "location": "/prfm/#programmiersprachen-und-formale-methoden", 
            "text": "Introduction", 
            "title": "Programmiersprachen und formale Methoden"
        }, 
        {
            "location": "/prfm/introduction/", 
            "text": "Introduction\n\n\nMotivation\n\n\n\n\nUsing a formal language to describe and solve problems is central to software engineering\n\n\nProgramming language theory involves mathematics, software engineering and linguistics\n\n\nMain emphasis: Comparative programming language analysis\n\n\nLike in other engineering disciplines, a mathematical analysis can contribute to a reliable and robust design\n\n\n\n\nDefinitions\n\n\n\n\nFormal language: Set of strings (symbols) constrained by specific rules\n\n\nThe set of formal languages is a subset of context-free languages\n\n\nAll programming languages are formal, we need to be able to interpret them computationally\n\n\n\n\n\n\nInformal language: Any natural language\n\n\n\n\nGoals\n\n\n\n\nUnderstanding of programming paradigms outside OO/imperative\n\n\nCreate programs in functional and logical styles\n\n\nFormal foundations of programming languages\n\n\nBridge the gap between \"computer science\" and theoretical disciplines and practical software engineering\n\n\nShift from execution-based thinking to rule-based thinking\n\n\n\n\nProgramming Paradigms\n\n\n\n\nOOP is not a paradigm in this sense here, more a way of organizing your code (built on the imperative paradigm)", 
            "title": "Introduction"
        }, 
        {
            "location": "/prfm/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/prfm/introduction/#motivation", 
            "text": "Using a formal language to describe and solve problems is central to software engineering  Programming language theory involves mathematics, software engineering and linguistics  Main emphasis: Comparative programming language analysis  Like in other engineering disciplines, a mathematical analysis can contribute to a reliable and robust design", 
            "title": "Motivation"
        }, 
        {
            "location": "/prfm/introduction/#definitions", 
            "text": "Formal language: Set of strings (symbols) constrained by specific rules  The set of formal languages is a subset of context-free languages  All programming languages are formal, we need to be able to interpret them computationally    Informal language: Any natural language", 
            "title": "Definitions"
        }, 
        {
            "location": "/prfm/introduction/#goals", 
            "text": "Understanding of programming paradigms outside OO/imperative  Create programs in functional and logical styles  Formal foundations of programming languages  Bridge the gap between \"computer science\" and theoretical disciplines and practical software engineering  Shift from execution-based thinking to rule-based thinking", 
            "title": "Goals"
        }, 
        {
            "location": "/prfm/introduction/#programming-paradigms", 
            "text": "OOP is not a paradigm in this sense here, more a way of organizing your code (built on the imperative paradigm)", 
            "title": "Programming Paradigms"
        }, 
        {
            "location": "/prfm/formal_proof/", 
            "text": "Formal Proof\n\n\n\n\nAn axiom is a proof rule without antecedents\n\n\nEvery proof tree has an axiom at the top (starting with the root at the bottom)\n\n\nA theory is a set of proof rules\n\n\nThis set is usually infinite and specified using a set of \nproof rule schemas", 
            "title": "Formal Proof"
        }, 
        {
            "location": "/prfm/formal_proof/#formal-proof", 
            "text": "An axiom is a proof rule without antecedents  Every proof tree has an axiom at the top (starting with the root at the bottom)  A theory is a set of proof rules  This set is usually infinite and specified using a set of  proof rule schemas", 
            "title": "Formal Proof"
        }, 
        {
            "location": "/prfm/propositional_calculus/", 
            "text": "Propositional Calculus\n\n\nBasic PC\n\n\n\n\nContains the basic set of PC (like NAND in computing)\n\n\nA \nPredicate\n is a formal statement that is either \ntrue\n or \nfalse\n\n\n\n\n\\vdash\n: \"Turnstile\" or \"tee\"\n\n\n\n\nH \\vdash G\n: \"Prove \nG\n under Hyphotheses \nH\n\"\n\n\nTurnstiles are \"implications\" on the level of a sequent, whereas \"\n\\Rightarrow\n\" is an implication on the predicate level\n\n\n\n\nBasicPC Syntax\n\n\n\n\nExamples of possible strings: \n\\bot\n, \n\\lnot\\bot\n, \n\\bot \\land \\bot\n\n\n\n\n\n\nProof Rule Schemas\n\n\n\n\nSchemas represent an infinite number of proof rules of the same form\n\n\nThey use \nmeta variables\n. If these are instantiated, they become a concrete proof rule\n\n\n\n\n\n\nTodo\n\n\nPut \n\\land\\ goal\n as outer fraction\n\n\n\n\nExample: Prove \nP \\land Q \\vdash Q \\land P\n\n\n\n\n\n\n\\frac{\\frac{\\frac{}{P, Q \\vdash Q}hyp \\frac{}{P, Q \\vdash P} hyp}{P, Q \\vdash Q \\land P} \\land goal}{P\\land Q \\vdash Q \\land P} \\land hyp\n\n\n\n\n\n\nEvery \"string\" you can generate using the basicPC Syntax can be used to instantiate a meta variable\n\n\n\n\nH\n can be an empty set\n\n\n\n\nExtending the syntax\n\n\n\n\nWe extend basicPC by introducing \"syntactic sugar\", new Symbols like \nT\n for True and \n\\lor\n\n\n\n\nThese syntactical equivalences can be used like proof rules\n\n\nAll the new rules of PC can be proven with the basicPC proof schemas", 
            "title": "Propositional Calculus"
        }, 
        {
            "location": "/prfm/propositional_calculus/#propositional-calculus", 
            "text": "", 
            "title": "Propositional Calculus"
        }, 
        {
            "location": "/prfm/propositional_calculus/#basic-pc", 
            "text": "Contains the basic set of PC (like NAND in computing)  A  Predicate  is a formal statement that is either  true  or  false   \\vdash : \"Turnstile\" or \"tee\"   H \\vdash G : \"Prove  G  under Hyphotheses  H \"  Turnstiles are \"implications\" on the level of a sequent, whereas \" \\Rightarrow \" is an implication on the predicate level", 
            "title": "Basic PC"
        }, 
        {
            "location": "/prfm/propositional_calculus/#basicpc-syntax", 
            "text": "Examples of possible strings:  \\bot ,  \\lnot\\bot ,  \\bot \\land \\bot", 
            "title": "BasicPC Syntax"
        }, 
        {
            "location": "/prfm/propositional_calculus/#proof-rule-schemas", 
            "text": "Schemas represent an infinite number of proof rules of the same form  They use  meta variables . If these are instantiated, they become a concrete proof rule    Todo  Put  \\land\\ goal  as outer fraction   Example: Prove  P \\land Q \\vdash Q \\land P    \\frac{\\frac{\\frac{}{P, Q \\vdash Q}hyp \\frac{}{P, Q \\vdash P} hyp}{P, Q \\vdash Q \\land P} \\land goal}{P\\land Q \\vdash Q \\land P} \\land hyp    Every \"string\" you can generate using the basicPC Syntax can be used to instantiate a meta variable   H  can be an empty set", 
            "title": "Proof Rule Schemas"
        }, 
        {
            "location": "/prfm/propositional_calculus/#extending-the-syntax", 
            "text": "We extend basicPC by introducing \"syntactic sugar\", new Symbols like  T  for True and  \\lor   These syntactical equivalences can be used like proof rules  All the new rules of PC can be proven with the basicPC proof schemas", 
            "title": "Extending the syntax"
        }, 
        {
            "location": "/prfm/logic_programming_intro/", 
            "text": "Logic Programming Introduction\n\n\nOnline Version of Learn Prolog Now: \nhttp://www.learnprolognow.org/\n\n\nHello World\n\n\n\n\nHypthoses are the \"knowledge base\"\n\n\nRules \nm(X):- h(X).\n-\n \n\\forall x.H(x) \\Rightarrow M(x)\n\n\n\n\n\"implied by\" - it's reversed!\n\n\n\n\n\n\nFacts: \nh(s).\n\n\n\n\n\n\nQuery: \n?- m(s).\n\n\n\n\n\\forall x\n is implied with uppercase variables\n\n\n\n\nKnowledge Base\n\n\n\n\nHypotheses, called \"Knowledge Base\"\n\n\nEvery statement is a \"clause\" and ends with a \n.\n\n\n\n\n1\n2\n3\n4\n5\nwoman\n(\nmia\n).\n\n\nwoman\n(\njody\n).\n\n\nwoman\n(\nyolanda\n).\n\n\nplaysAirGuitar\n(\njody\n).\n\n\nparty\n.\n\n\n\n\n\n\n\n\n\nIf a query cannot be proven true, it is \nfalse\n\n\nUnknown predicates return either \nfalse\n or throw an error (depending on the compiler)\n\n\n\n\nRules\n\n\n1\n2\n3\n4\n5\nhappy\n(\nyolanda\n).\n \n// fact\n\n\nlistens2music\n(\nmia\n).\n \n// fact\n\n\nlistens2music\n(\nyolanda\n)\n:-\n \nhappy\n(\nyolanda\n).\n \n// rule\n\n\nplaysAirGuitar\n(\nmia\n)\n:-\n \nlistens2music\n(\nmia\n).\n\n\nplaysAirGuitar\n(\nyolanda\n)\n:-\n \nlistens2music\n(\nyolanda\n).\n\n\n\n\n\n\n\n\n\nRead: \nhappy(yolanda) =\n listens2music(yolanda)\n (Reversed)\n\n\n\n\nConjuction\n\n\n1\n2\n3\nplaysAirGuitar\n(\nvincent\n)\n:-\n\n    \nlistens2music\n(\nvincent\n),\n\n    \nhappy\n(\nvincent\n).\n\n\n\n\n\n\n\n\n\nRead: \"vincent plays air guitar if he listens to music \nand\n he's happy\"\n\n\n\n\nDisjuction\n\n\n\n\n;\n instead of \n,\n\n\n\n\nSame as defining to rules with the same goal\n\n\n\n\n\n\nThere's no negation in Prolog. An absence of rule is basically a negation\n\n\n\n\nProlog does no proofs of contradiction, but \"negation as failure\" (to construct a proof tree)\n\n\n\n\n\n\n\n\nAsking for alternatives\n\n\n\n\n?- woman(X)\n gives every \nX\n that satisfies \n\\exists x.woman(x)\n\n\n\n\n(Uppercase) variables in the Knowledge Base take into account every occurence (\n\\forall\n universially quantified)\n\n\n\n\nSyntax\n\n\n\n\nAtoms are strings \nstarting with a lowercase letter\n or arbitrary strings in \n''\n\n\nNumbers are integers or floats (no type-checking)\n\n\nVariables are Strings starting with an \nUppercase Letter\n or with a \n_\n\n\nVariables are always \"bound\" in a \n\\exists\n or \n\\forall\n\n\n\n\nThe variable \n_\n is a \"wildcard\"\n\n\n\n\n\n\nComplex Terms are e.g. \nplaysAirGuitar(mia)\n\n\nThe functor must be an atom\n\n\n\n\n\n\n\"Arity\" is the number of arguments in a complex term\n\n\nTwo predicates with different arity are treated as sepparate", 
            "title": "Logical Programming Intro"
        }, 
        {
            "location": "/prfm/logic_programming_intro/#logic-programming-introduction", 
            "text": "Online Version of Learn Prolog Now:  http://www.learnprolognow.org/", 
            "title": "Logic Programming Introduction"
        }, 
        {
            "location": "/prfm/logic_programming_intro/#hello-world", 
            "text": "Hypthoses are the \"knowledge base\"  Rules  m(X):- h(X). -   \\forall x.H(x) \\Rightarrow M(x)   \"implied by\" - it's reversed!    Facts:  h(s).    Query:  ?- m(s).   \\forall x  is implied with uppercase variables", 
            "title": "Hello World"
        }, 
        {
            "location": "/prfm/logic_programming_intro/#knowledge-base", 
            "text": "Hypotheses, called \"Knowledge Base\"  Every statement is a \"clause\" and ends with a  .   1\n2\n3\n4\n5 woman ( mia ).  woman ( jody ).  woman ( yolanda ).  playsAirGuitar ( jody ).  party .     If a query cannot be proven true, it is  false  Unknown predicates return either  false  or throw an error (depending on the compiler)", 
            "title": "Knowledge Base"
        }, 
        {
            "location": "/prfm/logic_programming_intro/#rules", 
            "text": "1\n2\n3\n4\n5 happy ( yolanda ).   // fact  listens2music ( mia ).   // fact  listens2music ( yolanda ) :-   happy ( yolanda ).   // rule  playsAirGuitar ( mia ) :-   listens2music ( mia ).  playsAirGuitar ( yolanda ) :-   listens2music ( yolanda ).     Read:  happy(yolanda) =  listens2music(yolanda)  (Reversed)", 
            "title": "Rules"
        }, 
        {
            "location": "/prfm/logic_programming_intro/#conjuction", 
            "text": "1\n2\n3 playsAirGuitar ( vincent ) :- \n     listens2music ( vincent ), \n     happy ( vincent ).     Read: \"vincent plays air guitar if he listens to music  and  he's happy\"", 
            "title": "Conjuction"
        }, 
        {
            "location": "/prfm/logic_programming_intro/#disjuction", 
            "text": ";  instead of  ,   Same as defining to rules with the same goal    There's no negation in Prolog. An absence of rule is basically a negation   Prolog does no proofs of contradiction, but \"negation as failure\" (to construct a proof tree)", 
            "title": "Disjuction"
        }, 
        {
            "location": "/prfm/logic_programming_intro/#asking-for-alternatives", 
            "text": "?- woman(X)  gives every  X  that satisfies  \\exists x.woman(x)   (Uppercase) variables in the Knowledge Base take into account every occurence ( \\forall  universially quantified)", 
            "title": "Asking for alternatives"
        }, 
        {
            "location": "/prfm/logic_programming_intro/#syntax", 
            "text": "Atoms are strings  starting with a lowercase letter  or arbitrary strings in  ''  Numbers are integers or floats (no type-checking)  Variables are Strings starting with an  Uppercase Letter  or with a  _  Variables are always \"bound\" in a  \\exists  or  \\forall   The variable  _  is a \"wildcard\"    Complex Terms are e.g.  playsAirGuitar(mia)  The functor must be an atom    \"Arity\" is the number of arguments in a complex term  Two predicates with different arity are treated as sepparate", 
            "title": "Syntax"
        }, 
        {
            "location": "/prfm/prolog_unification/", 
            "text": "Prolog Unification and Proof Search\n\n\nUnification\n\n\n\n\nUnification instantiates variables such that two terms are equal\n\n\nwoman(Z)\n and \nwoman(X)\n unifies, because \nX\n can be instantiated with \nmia\n\n\nloves(mia, X)\n and \nloves(X, vincent)\n cannnot be unified, \nX\n needs to be instantiated with one value\n\n\nIn Prolog, unification can be done with \n=\n\n\nProlog ignores the \"occurs check\" (recursive)\n\n\nfather(X) = X\n does not unify with the theoretical definition (would be \nfather(father(father(...)...))\n)\n\n\n\n\n\n\nProlog will give the most general solution, e.g. when there are infinite solutions with 1 free variable, it will state a variable for that\n\n\n\n\nProof Search\n\n\n\n\nFor the query, try unifying it with an expression from the knowledge base. Repeat for every found unification.\n\n\nWhen proof is found, backtrack upwards to find the instantiation\n\n\nSearch Tree example: Try unify, then check every possible instantiaton (here \na\n and \nb\n)\n\n\nRecursive with backtracking, i.e. it goes down of the left side first (\"depth-first\"), then backtrack upwards\n\n\nEvery branch is a proof. The proof search tree searches for all possible proofs. Not to confuse with the proof tree from PC, where only 1 proof was needed!", 
            "title": "Prolog Unification"
        }, 
        {
            "location": "/prfm/prolog_unification/#prolog-unification-and-proof-search", 
            "text": "", 
            "title": "Prolog Unification and Proof Search"
        }, 
        {
            "location": "/prfm/prolog_unification/#unification", 
            "text": "Unification instantiates variables such that two terms are equal  woman(Z)  and  woman(X)  unifies, because  X  can be instantiated with  mia  loves(mia, X)  and  loves(X, vincent)  cannnot be unified,  X  needs to be instantiated with one value  In Prolog, unification can be done with  =  Prolog ignores the \"occurs check\" (recursive)  father(X) = X  does not unify with the theoretical definition (would be  father(father(father(...)...)) )    Prolog will give the most general solution, e.g. when there are infinite solutions with 1 free variable, it will state a variable for that", 
            "title": "Unification"
        }, 
        {
            "location": "/prfm/prolog_unification/#proof-search", 
            "text": "For the query, try unifying it with an expression from the knowledge base. Repeat for every found unification.  When proof is found, backtrack upwards to find the instantiation  Search Tree example: Try unify, then check every possible instantiaton (here  a  and  b )  Recursive with backtracking, i.e. it goes down of the left side first (\"depth-first\"), then backtrack upwards  Every branch is a proof. The proof search tree searches for all possible proofs. Not to confuse with the proof tree from PC, where only 1 proof was needed!", 
            "title": "Proof Search"
        }, 
        {
            "location": "/prfm/prolog_lists/", 
            "text": "Prolog Lists\n\n\n\n\nList elements can have arbitrary \"types\" (mixed)\n\n\n\n\nRecursive Definition\n\n\n\n\nEither\n\n\nan empty list: \n[]\n\n\na non-empty list:\n\n\na head = first element\n\n\ntail: every other element (another list)\n\n\n\n\n\n\n\n\n\n\n[H|T]\n to split head and tail for pattern matching\n\n\nUse wildcards \n_\n as \"anonymous variables\"\n\n\n\n\nMember Predicate\n\n\n\n\nmember/2\n: Determine whether something is an element of a list\n\n\n\n\n1\n2\nmember\n(\nX\n,[\nX\n|\nT\n]).\n\n\nmember\n(\nX\n,[\nH\n|\nT\n])\n \n:-\n \nmember\n(\nX\n,\nT\n)\n\n\n\n\n\n\n\na2b Predicate\n\n\n\n\nfirst argument is list of \na\ns, second argument is list ob \nb\ns with same length of first list\n\n\n\n\n1\n2\na2b\n([],\n \n[]).\n \n% base case\n\n\na2b\n([\na\n|\nLa\n],\n \n[\nb\n|\nLb\n])\n \n:-\n \na2b\n(\nLa\n,\n \nLb\n)\n\n\n\n\n\n\n\nappend/3\n\n\n\n\nappend(L1, l2, L3)\n\n\nL3\n is \nL1 + L2\n\n\n\n\n1\n2\n3\n4\nappend\n([],\n \nL\n,\n \nL\n).\n\n\nappend\n(\nL\n,\n \n[],\n \nL\n).\n\n\nappend\n([\nH\n|\nT\n],\n \nL2\n,\n \nL4\n)\n \n:-\n \nappend\n(\nT\n,\n \nL2\n,\n \nL3\n),\n\n                         \nL4\n \n=\n \n[\nH\n|\nL3\n].\n\n\n\n\n\n\n\nsublist\n\n\n\n\nsublist(Lsub, L)\n\n\nSublists are the prefixes of suffixes\n\n\n\n\n1\n2\n3\nsublist\n(\nSub\n,\nList\n)\n \n:-\n\n    \nsuffix\n(\nSuffix\n,\n \nList\n),\n\n    \nprefix\n(\nSub\n,\n \nSuffix\n)", 
            "title": "Prolog Lists"
        }, 
        {
            "location": "/prfm/prolog_lists/#prolog-lists", 
            "text": "List elements can have arbitrary \"types\" (mixed)", 
            "title": "Prolog Lists"
        }, 
        {
            "location": "/prfm/prolog_lists/#recursive-definition", 
            "text": "Either  an empty list:  []  a non-empty list:  a head = first element  tail: every other element (another list)      [H|T]  to split head and tail for pattern matching  Use wildcards  _  as \"anonymous variables\"", 
            "title": "Recursive Definition"
        }, 
        {
            "location": "/prfm/prolog_lists/#member-predicate", 
            "text": "member/2 : Determine whether something is an element of a list   1\n2 member ( X ,[ X | T ]).  member ( X ,[ H | T ])   :-   member ( X , T )", 
            "title": "Member Predicate"
        }, 
        {
            "location": "/prfm/prolog_lists/#a2b-predicate", 
            "text": "first argument is list of  a s, second argument is list ob  b s with same length of first list   1\n2 a2b ([],   []).   % base case  a2b ([ a | La ],   [ b | Lb ])   :-   a2b ( La ,   Lb )", 
            "title": "a2b Predicate"
        }, 
        {
            "location": "/prfm/prolog_lists/#append3", 
            "text": "append(L1, l2, L3)  L3  is  L1 + L2   1\n2\n3\n4 append ([],   L ,   L ).  append ( L ,   [],   L ).  append ([ H | T ],   L2 ,   L4 )   :-   append ( T ,   L2 ,   L3 ), \n                          L4   =   [ H | L3 ].", 
            "title": "append/3"
        }, 
        {
            "location": "/prfm/prolog_lists/#sublist", 
            "text": "sublist(Lsub, L)  Sublists are the prefixes of suffixes   1\n2\n3 sublist ( Sub , List )   :- \n     suffix ( Suffix ,   List ), \n     prefix ( Sub ,   Suffix )", 
            "title": "sublist"
        }, 
        {
            "location": "/prfm/prolog-recursion/", 
            "text": "Prolog Recursion\n\n\n\n\nLoops use a global state, declarative programming languages don't have that\n\n\nTherefore, recursion is the only way to do such computation\n\n\n\n\n\n\nNon-terminating programs give an \"out of stack\" error\n\n\nProlog processes the knowledge base from top to bottom and left to right\n\n\nThis determines the order of the output\n\n\n\n\n\n\nRecursion call must always be placed torwards the end of a rule, otherwise it will iterate over the incursion infinitely!", 
            "title": "Prolog Recursion"
        }, 
        {
            "location": "/prfm/prolog-recursion/#prolog-recursion", 
            "text": "Loops use a global state, declarative programming languages don't have that  Therefore, recursion is the only way to do such computation    Non-terminating programs give an \"out of stack\" error  Prolog processes the knowledge base from top to bottom and left to right  This determines the order of the output    Recursion call must always be placed torwards the end of a rule, otherwise it will iterate over the incursion infinitely!", 
            "title": "Prolog Recursion"
        }, 
        {
            "location": "/prfm/prolog_arithmetic/", 
            "text": "Prolog Arithmetic\n\n\n\n\n+, -, /, *\n are functors with arity 2\n\n\nstatements like \n3+2\n are ordinary terms\n\n\n+(3,2)\n\n\n\n\n\n\n\n\nis predicate\n\n\n\n\nlike \n==\n\n\nboth sides of the predicate get evaluated\n\n\nWorks for integer and real numbers\n\n\nRight-hand site must be concrete, e.g. NOT \n3+2 is X\n\n\n\n\nList Arithmetic\n\n\n1\n2\n3\n4\n% len(list, size)\n\n\n\nlen\n([],\n \n0\n).\n \n\nlen\n([\nH\n|\nT\n],\n \nN\n)\n \n:-\n \nlen\n(\nT\n,\n \nN1\n),\n \nN\n \nis\n \nN1\n+\n1.\n\n\n\n\n\n\n\nTail Recursion\n\n\nacclen/3\n\n\n\n\nacclen(list, acc, size)\n\n\naccumulator starts with 0 and counts up\n\n\n\n\n1\n2\n3\n4\nlen\n(\nL\n,\nN\n)\n \n:-\n \nacclen\n(\nL\n,\n0\n,\nN\n).\n\n\nacclen\n([],\n \nA\n,\n \nN\n)\n \n:-\n \nA\n \n=\n \nN\n.\n\n\nacclen\n([\nH\n|\nT\n],\n \nA\n,\n \nN\n)\n \n:-\n \nA1\n \nis\n \nA\n \n+\n \n1\n,\n \n                       \nacclen\n(\nT\n,\n \nA1\n,\n \nN\n).\n\n\n\n\n\n\n\nmax/2\n\n\n\n\nmax(list, maxElem)\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\nmax\n([\nE\n],\n \nE\n).\n\n\nmax\n([\nH\n|\nT\n],\n \nM\n)\n \n:-\n \nmax\n(\nT\n,\n \nMT\n),\n\n                 \nH\n \n \nMT\n,\n\n                 \nM\n \n=\n \nH\n.\n\n\nmax\n([\nH\n|\nT\n],\n \nM\n)\n \n:-\n \nmax\n(\nT\n,\n \nMT\n),\n \n                 \nH\n \n=\n \nMT\n,\n\n                 \nM\n \n=\n \nMT\n.", 
            "title": "Prolog Arithmetic"
        }, 
        {
            "location": "/prfm/prolog_arithmetic/#prolog-arithmetic", 
            "text": "+, -, /, *  are functors with arity 2  statements like  3+2  are ordinary terms  +(3,2)", 
            "title": "Prolog Arithmetic"
        }, 
        {
            "location": "/prfm/prolog_arithmetic/#is-predicate", 
            "text": "like  ==  both sides of the predicate get evaluated  Works for integer and real numbers  Right-hand site must be concrete, e.g. NOT  3+2 is X", 
            "title": "is predicate"
        }, 
        {
            "location": "/prfm/prolog_arithmetic/#list-arithmetic", 
            "text": "1\n2\n3\n4 % len(list, size)  len ([],   0 ).   len ([ H | T ],   N )   :-   len ( T ,   N1 ),   N   is   N1 + 1.", 
            "title": "List Arithmetic"
        }, 
        {
            "location": "/prfm/prolog_arithmetic/#tail-recursion", 
            "text": "", 
            "title": "Tail Recursion"
        }, 
        {
            "location": "/prfm/prolog_arithmetic/#acclen3", 
            "text": "acclen(list, acc, size)  accumulator starts with 0 and counts up   1\n2\n3\n4 len ( L , N )   :-   acclen ( L , 0 , N ).  acclen ([],   A ,   N )   :-   A   =   N .  acclen ([ H | T ],   A ,   N )   :-   A1   is   A   +   1 ,  \n                        acclen ( T ,   A1 ,   N ).", 
            "title": "acclen/3"
        }, 
        {
            "location": "/prfm/prolog_arithmetic/#max2", 
            "text": "max(list, maxElem)   1\n2\n3\n4\n5\n6\n7 max ([ E ],   E ).  max ([ H | T ],   M )   :-   max ( T ,   MT ), \n                  H     MT , \n                  M   =   H .  max ([ H | T ],   M )   :-   max ( T ,   MT ),  \n                  H   =   MT , \n                  M   =   MT .", 
            "title": "max/2"
        }, 
        {
            "location": "/prfm/prolog_under-hood/", 
            "text": "Prolog under the hood\n\n\n\n\nProlog is a subset of \nFoPCe\n\n\nA horn clause is a disjunction of literals where at most one literal is positive\n\n\n\n\nProof by resolution\n\n\n\n\nUnion Sets in clauses and goals where a predicate is positive in one and negative in the other\n\n\ne.g. \n{\\lnotA, \\lnotB, C} \\union {\\lnotC}\n\n\n\n\n\n\n\n\nRepeat until set of goal clauses is empty", 
            "title": "Prolog Under the Hood"
        }, 
        {
            "location": "/prfm/prolog_under-hood/#prolog-under-the-hood", 
            "text": "Prolog is a subset of  FoPCe  A horn clause is a disjunction of literals where at most one literal is positive", 
            "title": "Prolog under the hood"
        }, 
        {
            "location": "/prfm/prolog_under-hood/#proof-by-resolution", 
            "text": "Union Sets in clauses and goals where a predicate is positive in one and negative in the other  e.g.  {\\lnotA, \\lnotB, C} \\union {\\lnotC}     Repeat until set of goal clauses is empty", 
            "title": "Proof by resolution"
        }, 
        {
            "location": "/prfm/lambda_calculus/", 
            "text": "Lambda Calculus\n\n\n\n\nWe will only look at pure untyped calculus\n\n\nLC builds directly on Sequent Calculus\n\n\n\n\nConventions\n\n\n\n\nApplication \nM M\n binds tighter than abstraction\n\n\nApplication is left associative\n\n\n\n\nFree and Bound variables\n\n\n\n\n\n\n\\lambda y.\n can be thought of as a quantifier\n\n\nBound variables are like parameters\n\n\ne.g. in an integral \n\\int{yx^2}{dx}\n, x is bound\n\n\n\n\n\n\n\n\nBeta Redcution\n\n\n\n\nReplace every \nx\n in the abstraction \nM\n with \nN\n\n\n\n\n\n\n\n\n\\frac{}{H\\vdash (\\lambda x. M) N = [x := N]M}\\beta\n\n\n\n\n\n\n\n\nExamples:\n\n\n\n\n\n\n(\\lambda x. square x) 5 = square 5\n\n\n\n\n\n\n(\\lambda x. square x) (\\lambda y. square y) 5 = (square (\\lambda y. square y)) 5\n\n\n\n\nNo further resolution!\n\n\n\n\n\n\n\n\n\n\n\n\nEven if there are different strategies of how to resolute something, the result is always the same", 
            "title": "Lambda Calculus"
        }, 
        {
            "location": "/prfm/lambda_calculus/#lambda-calculus", 
            "text": "We will only look at pure untyped calculus  LC builds directly on Sequent Calculus", 
            "title": "Lambda Calculus"
        }, 
        {
            "location": "/prfm/lambda_calculus/#conventions", 
            "text": "Application  M M  binds tighter than abstraction  Application is left associative", 
            "title": "Conventions"
        }, 
        {
            "location": "/prfm/lambda_calculus/#free-and-bound-variables", 
            "text": "\\lambda y.  can be thought of as a quantifier  Bound variables are like parameters  e.g. in an integral  \\int{yx^2}{dx} , x is bound", 
            "title": "Free and Bound variables"
        }, 
        {
            "location": "/prfm/lambda_calculus/#beta-redcution", 
            "text": "Replace every  x  in the abstraction  M  with  N     \\frac{}{H\\vdash (\\lambda x. M) N = [x := N]M}\\beta     Examples:    (\\lambda x. square x) 5 = square 5    (\\lambda x. square x) (\\lambda y. square y) 5 = (square (\\lambda y. square y)) 5   No further resolution!       Even if there are different strategies of how to resolute something, the result is always the same", 
            "title": "Beta Redcution"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/", 
            "text": "Computation with the Lambda Calculus\n\n\nNormal Form\n\n\n\n\nA \n\\lambda\n Term is in \n\\beta\n-normal form, iff no further reductions can be applied to it\n\n\nIt's possible to have a different ordering of the resolution, but they all lead to the normal form\n\n\nEvery \n\\lambda\n-term has at most one normal form\n\n\nThat makes computation deterministic\n\n\n\n\n\n\nNot all \n\\lambda\n-terms terminate i.e. have a normal form\n\n\ne.g. \n(\\lambda x.\\,x\\,x)(\\lambda x.\\,x\\,x)\n\n\n\n\nNecessary to make it Turing-complete\n\n\n\n\n\n\n\n\nCurrying\n\n\n\n\n\n\n\\lambda\n-terms only allow single argument functions\n\n\nHow to implement functions with multiple Arguments?\n\n\nCurrying: \nf(x, y) = f\\,x\\,y\n\n\n\n\nApply \nf\n to \nx\n, which returns a function that takes \ny\n\n\n\n\nApply this function to \ny\n\n\n\n\n\n\n\n\n\n\n\n\n\\delta\n-Reduction\n\n\n\n\nSubstitute a defined symbol with its definition\n\n\ne.g. \nsquare(x)\n substituted is \n\\lambda x.\\,*\\,x\\,x\n\n\n\n\n\n\nHigher Order Functions\n\n\n\n\nFunctions that either takes a function as input or returns a function\n\n\nfunctions are \"first-class citizens\"\n\n\n\n\nEvaluation Strategies\n\n\n\n\nA redex (reducible expression) is a any Delta- oder Beta-reducible lambda term\n\n\nStrategie plays a role in the length of derivations and if they terminate\n\n\nThere are an arbitrary number of evaluation strategies\n\n\nInnermost- and Outermost-First are \"extreme\" cases\n\n\n\n\nInnermost-first (applicative order)\n\n\n\n\nThe innermost redex is reduced first\n\n\nIf multiple possible, the leftmost is reduced first\n\n\nA redex is innermost if there is no other redex inside it\n\n\n\n\nOutermost-first (normal order)\n\n\n\n\nThe outermost redex is reduced first\n\n\nIf multiple possible, the leftmost is reduced first\n\n\nA redex is outermost if there is no other redex outside it\n\n\n\n\nComparison\n\n\n\n\ninnermost-first: Arguments are reduced exactly once (even if they're not used)\n\n\noutermost-first: Arguments are reduced as often as they're needed (can be multiple times for one)\n\n\ninnermost-first doesn't always result in shorter derivations\n\n\nOutermost-first always ends in a normal form if it exists\n\n\ninnermost-first may not terminate, e.g. when a non-terminating redux is an argument, but never used\n\n\n\n\n\n\ninnermost-first is like \"call by value\", outermost-first like \"call by ref\"\n\n\n\n\nLazy Evaluation\n\n\n\n\nMake call-by-name more efficient\n\n\nCache evaluations to evaluate arguments only once\n\n\nDefault for Haskell\n\n\n\n\nEncoding Data and Operations\n\n\n\n\nPure lambda does not have primitive data types\n\n\nWe need numbers, booleans \n pairs to construct arbitrary data types\n\n\nThese definitions correspond to AND/OR-Gates on a real CPU (low-level)\n\n\n\n\nBooleans\n\n\n\n\nIt's hard to have an intuition for these, try to prove some properties that must hold (truth tables)\n\n\n\n\nArithmetic\n\n\n\n\nFor every number n, apply a function n times", 
            "title": "Lambda Computation"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#computation-with-the-lambda-calculus", 
            "text": "", 
            "title": "Computation with the Lambda Calculus"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#normal-form", 
            "text": "A  \\lambda  Term is in  \\beta -normal form, iff no further reductions can be applied to it  It's possible to have a different ordering of the resolution, but they all lead to the normal form  Every  \\lambda -term has at most one normal form  That makes computation deterministic    Not all  \\lambda -terms terminate i.e. have a normal form  e.g.  (\\lambda x.\\,x\\,x)(\\lambda x.\\,x\\,x)   Necessary to make it Turing-complete", 
            "title": "Normal Form"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#currying", 
            "text": "\\lambda -terms only allow single argument functions  How to implement functions with multiple Arguments?  Currying:  f(x, y) = f\\,x\\,y   Apply  f  to  x , which returns a function that takes  y   Apply this function to  y", 
            "title": "Currying"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#delta-reduction", 
            "text": "Substitute a defined symbol with its definition  e.g.  square(x)  substituted is  \\lambda x.\\,*\\,x\\,x", 
            "title": "\\delta-Reduction"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#higher-order-functions", 
            "text": "Functions that either takes a function as input or returns a function  functions are \"first-class citizens\"", 
            "title": "Higher Order Functions"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#evaluation-strategies", 
            "text": "A redex (reducible expression) is a any Delta- oder Beta-reducible lambda term  Strategie plays a role in the length of derivations and if they terminate  There are an arbitrary number of evaluation strategies  Innermost- and Outermost-First are \"extreme\" cases", 
            "title": "Evaluation Strategies"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#innermost-first-applicative-order", 
            "text": "The innermost redex is reduced first  If multiple possible, the leftmost is reduced first  A redex is innermost if there is no other redex inside it", 
            "title": "Innermost-first (applicative order)"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#outermost-first-normal-order", 
            "text": "The outermost redex is reduced first  If multiple possible, the leftmost is reduced first  A redex is outermost if there is no other redex outside it", 
            "title": "Outermost-first (normal order)"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#comparison", 
            "text": "innermost-first: Arguments are reduced exactly once (even if they're not used)  outermost-first: Arguments are reduced as often as they're needed (can be multiple times for one)  innermost-first doesn't always result in shorter derivations  Outermost-first always ends in a normal form if it exists  innermost-first may not terminate, e.g. when a non-terminating redux is an argument, but never used    innermost-first is like \"call by value\", outermost-first like \"call by ref\"", 
            "title": "Comparison"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#lazy-evaluation", 
            "text": "Make call-by-name more efficient  Cache evaluations to evaluate arguments only once  Default for Haskell", 
            "title": "Lazy Evaluation"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#encoding-data-and-operations", 
            "text": "Pure lambda does not have primitive data types  We need numbers, booleans   pairs to construct arbitrary data types  These definitions correspond to AND/OR-Gates on a real CPU (low-level)", 
            "title": "Encoding Data and Operations"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#booleans", 
            "text": "It's hard to have an intuition for these, try to prove some properties that must hold (truth tables)", 
            "title": "Booleans"
        }, 
        {
            "location": "/prfm/computation_lambda_calculus/#arithmetic", 
            "text": "For every number n, apply a function n times", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/prfm/fp_introduction/", 
            "text": "Functional Programming Introduction\n\n\n\n\nFunctional Programming means no (or controlled) mutable state and sideeffect-free expressions\n\n\n\n\nNo mutable state\n\n\n\n\nf(x)\n only depends on the definition of \nf\n and the value of \nx\n (Referential Transparency)\n\n\nNo assignments or control structures\n\n\n\n\nFunctions\n\n\n\n\nFunctions are first-class-citizens, a.k.a. a \"primitive\" data type", 
            "title": "Functional Programming Intro"
        }, 
        {
            "location": "/prfm/fp_introduction/#functional-programming-introduction", 
            "text": "Functional Programming means no (or controlled) mutable state and sideeffect-free expressions", 
            "title": "Functional Programming Introduction"
        }, 
        {
            "location": "/prfm/fp_introduction/#no-mutable-state", 
            "text": "f(x)  only depends on the definition of  f  and the value of  x  (Referential Transparency)  No assignments or control structures", 
            "title": "No mutable state"
        }, 
        {
            "location": "/prfm/fp_introduction/#functions", 
            "text": "Functions are first-class-citizens, a.k.a. a \"primitive\" data type", 
            "title": "Functions"
        }, 
        {
            "location": "/prfm/haskell_first-steps/", 
            "text": "Haskell Introduction\n\n\n\n\nCons\n: Constructor\n\n\n[1, 2, 3] !! 1\n: Take second element from list\n\n\nInfix, compared to most other list functions!\n\n\n\n\n\n\nPrefix function application has preference\n\n\nConvention: Name list arguments with suffix \ns\n, e.g. \nxs\n\n\n\n\nTypes and Classes\n\n\n\n\nEvery well-formed expression has a type\n\n\ne :: t\n: expression \ne\n produces a value of \nt\n\n\nTypes are automatically determined by type inference at compile time\n\n\nIt will always determine the most general type (complete and total type inference)\n\n\n\n\n\n\nA list is a sequence of values of the \nsame\n type\n\n\ntype of a list is e.g. \n[Bool]\n or \n[Char]\n\n\n\n\n\n\nFunction types: \nf :: t1 -\n tResult\n\n\nCurried\n Functions: Functions which take \"multiple\" arguments, i.e. one argument at a time, e.g. \nadd'\n or \nmap\n\n\nThe arrow \n-\n associates to the right\n\n\n\n\n\n\nPolymorphic functions: Type contains one or more \ntype variables\n (like generics)\n\n\nType constraints\n\n\ne.g. \n(+) :: Num a =\n a -\n a -\n a\n\n\nNum a\n is a type constraint and can only occur once in a type\n\n\n\n\n\n\n\n\nBasic Types\n\n\n\n\nInt\n: Fixed-precision integer\n\n\nInteger\n: arbitrary-precision integer\n\n\n\n\nType Classes\n\n\n\n\nNum\n: Numeric Types\n\n\nEq\n: Equality types (e.g. for \n(==)\n)\n\n\nOrd\n: Ordered types (for comparison)\n\n\n\n\nDefining Functions\n\n\nConditional Expression\n\n\n\n\nabs n = if n \n= 0 then n else -n\n\n\nCan be nested\n\n\nMust always have an \nelse\n branch (to be unambiguous)\n\n\nGuarded Equations (syntactic sugar):\n\n\n\n\n1\n2\n3\nabs\n \nn\n\n    \n|\n \nn\n \n=\n \n0\n \n=\n \nn\n\n    \n|\n \notherwise\n \n=\n \n-\nn\n\n\n\n\n\n\n\nPattern Matching\n\n\n\n\nDefine functions with patterns\n\n\n_\n is a wildcard\n\n\nConditions are evaluated top-down\n\n\nDefinition should be exhaustive\n\n\n\n\n1\n2\nTrue\n \n \nTrue\n \n=\n \nTrue\n\n\n_\n \n \n_\n \n=\n \nFalse\n\n\n\n\n\n\n\nList Patterns\n\n\n\n\n:\n is the cons operator to concatenate two elements\n\n\nA list is defined as:\n\n\n\n\n1\n=\n \n[]\n \n|\n \n(\n_\n:\n_\n)\n\n\n\n\n\n\n\n\n\n[1, 2, 3]\n is syntactic sugar for \u00b41: (2: (3: []))\u00b4\n\n\n\n\nLambda expressions\n\n\n\u207b \n\\ x -\n x + x\n\n- \n\\\n is \n\\lambda\n\n- \n\\lambda x. (x+1) * 2\n is \n(*2).(+1)\n in \"point-free\" form\n\n\nOperator Sections\n\n\n\n\nInfix operators can be written as a curied functions in \n()\n\n\nlike \n(+) 1 2\n\n\n\n\n\n\nSelections: \n(1+)\n = \n\\lambda x. 1 + x\n is a \"plus one\" function\n\n\n\n\nList Comprehension\n\n\n\n\n[x^2 | x \n- [1..5]]\n\n\nx \n- [1..5]\n is a generator that generates values for \nx\n\n\n[(x, y) | x \n- [1, 2, 3], y \n- [4, 5]]\n\n\n[(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]\n\n\nNotice: the \ny\n generator is used up first\n\n\n\n\n\n\nThink of later generators as deeper nested loops\n\n\nlater generators can therefore depend on earlier ones\n\n\nDefining guards: \n[x | x \n- [1 .. 10], even x]\n\n\n\n\nZip function\n\n\n\n\nMap tWo lists to a list of pairs until one of the two lists ends\n\n\nzip :: [a] -\n [b] -\n [(a, b)]\n\n\n\n\n\n\nzip ['a', 'b', 'c'] [1, 2, 3, 4]\n - \n[('a',1),('b',2),('c',3)]\n\n\n\n\nString comprehensions\n\n\n\n\nStrings are represented as char lists, so they can be used like lists\n\n\n\n\nRecursive Functions\n\n\nHigher Order Functions\n\n\n\n\nFunction which accepts functions as arguments and/or returns a function\n\n\ne.g. \nmap f xs = [f x | x \n- xs]\n\n\nfilter p xs = [x | x \n- xs, p x]\n\n\nGeneral reduce / fold pattern: \nf (x : xs) = x (+) f xs\n where \n(+)\n is some operator\n\n\nfolder pattern is defined with \nfoldr\n\n\nfirst argument: operator like \n(+)\n above\n\n\nsecond argument: result for base case \n[]\n\n\ne.g. \nsum = foldr (+) 0\n\n\n\n\n\n\n(.)\n-function: \"of\"\n\n\nf . g = \\ x -\n f (g x)\n\n\n\n\n\n\n\n\nData Types\n\n\nPolymorphism\n\n\n\n\nSlide 30: This is parametric polymorphism\n\n\nHaskell uses type classes to achieve ad-hoc polymorphism\n\n\nSimilar to interfaces in Java\n\n\nclass declarations specify which functions the type must have, and the type of the functions\n\n\nclass types can be extended: \nclass Eq a =\n Ord a where ...\n extends \nEq\n\n\nFunctor is similar to the Visitor-Pattern\n\n\nThe compiler can automatically generate default implementations for polymorphism with \nderiving\n\n\n\n\nInteractive Programming\n\n\n\n\nWe need a way to input data with a keyboard and show data on a screen (side effects)\n\n\nSide effects are integrated into the type system of Haskell\n\n\nBasic Type: \nIO a\n: The type of actions that return a value of type \na\n\n\nIntuition: Function takes \"the world\" and returns it (possibly changed) along with a value\n\n\nIO ()\n is a type that returns no value\n\n\ngetChar\n and \nputChar\n read and write characters from keyboard to screen\n\n\ndo\n composes sequential actions together\n\n\nreturn\n returns a value in a \ndo\n\n\nassignment with \nx \n- func", 
            "title": "Haskell"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#haskell-introduction", 
            "text": "Cons : Constructor  [1, 2, 3] !! 1 : Take second element from list  Infix, compared to most other list functions!    Prefix function application has preference  Convention: Name list arguments with suffix  s , e.g.  xs", 
            "title": "Haskell Introduction"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#types-and-classes", 
            "text": "Every well-formed expression has a type  e :: t : expression  e  produces a value of  t  Types are automatically determined by type inference at compile time  It will always determine the most general type (complete and total type inference)    A list is a sequence of values of the  same  type  type of a list is e.g.  [Bool]  or  [Char]    Function types:  f :: t1 -  tResult  Curried  Functions: Functions which take \"multiple\" arguments, i.e. one argument at a time, e.g.  add'  or  map  The arrow  -  associates to the right    Polymorphic functions: Type contains one or more  type variables  (like generics)  Type constraints  e.g.  (+) :: Num a =  a -  a -  a  Num a  is a type constraint and can only occur once in a type", 
            "title": "Types and Classes"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#basic-types", 
            "text": "Int : Fixed-precision integer  Integer : arbitrary-precision integer", 
            "title": "Basic Types"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#type-classes", 
            "text": "Num : Numeric Types  Eq : Equality types (e.g. for  (==) )  Ord : Ordered types (for comparison)", 
            "title": "Type Classes"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#defining-functions", 
            "text": "", 
            "title": "Defining Functions"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#conditional-expression", 
            "text": "abs n = if n  = 0 then n else -n  Can be nested  Must always have an  else  branch (to be unambiguous)  Guarded Equations (syntactic sugar):   1\n2\n3 abs   n \n     |   n   =   0   =   n \n     |   otherwise   =   - n", 
            "title": "Conditional Expression"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#pattern-matching", 
            "text": "Define functions with patterns  _  is a wildcard  Conditions are evaluated top-down  Definition should be exhaustive   1\n2 True     True   =   True  _     _   =   False", 
            "title": "Pattern Matching"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#list-patterns", 
            "text": ":  is the cons operator to concatenate two elements  A list is defined as:   1 =   []   |   ( _ : _ )     [1, 2, 3]  is syntactic sugar for \u00b41: (2: (3: []))\u00b4", 
            "title": "List Patterns"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#lambda-expressions", 
            "text": "\u207b  \\ x -  x + x \n-  \\  is  \\lambda \n-  \\lambda x. (x+1) * 2  is  (*2).(+1)  in \"point-free\" form", 
            "title": "Lambda expressions"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#operator-sections", 
            "text": "Infix operators can be written as a curied functions in  ()  like  (+) 1 2    Selections:  (1+)  =  \\lambda x. 1 + x  is a \"plus one\" function", 
            "title": "Operator Sections"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#list-comprehension", 
            "text": "[x^2 | x  - [1..5]]  x  - [1..5]  is a generator that generates values for  x  [(x, y) | x  - [1, 2, 3], y  - [4, 5]]  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]  Notice: the  y  generator is used up first    Think of later generators as deeper nested loops  later generators can therefore depend on earlier ones  Defining guards:  [x | x  - [1 .. 10], even x]", 
            "title": "List Comprehension"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#zip-function", 
            "text": "Map tWo lists to a list of pairs until one of the two lists ends  zip :: [a] -  [b] -  [(a, b)]    zip ['a', 'b', 'c'] [1, 2, 3, 4]  -  [('a',1),('b',2),('c',3)]", 
            "title": "Zip function"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#string-comprehensions", 
            "text": "Strings are represented as char lists, so they can be used like lists", 
            "title": "String comprehensions"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#recursive-functions", 
            "text": "", 
            "title": "Recursive Functions"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#higher-order-functions", 
            "text": "Function which accepts functions as arguments and/or returns a function  e.g.  map f xs = [f x | x  - xs]  filter p xs = [x | x  - xs, p x]  General reduce / fold pattern:  f (x : xs) = x (+) f xs  where  (+)  is some operator  folder pattern is defined with  foldr  first argument: operator like  (+)  above  second argument: result for base case  []  e.g.  sum = foldr (+) 0    (.) -function: \"of\"  f . g = \\ x -  f (g x)", 
            "title": "Higher Order Functions"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#data-types", 
            "text": "", 
            "title": "Data Types"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#polymorphism", 
            "text": "Slide 30: This is parametric polymorphism  Haskell uses type classes to achieve ad-hoc polymorphism  Similar to interfaces in Java  class declarations specify which functions the type must have, and the type of the functions  class types can be extended:  class Eq a =  Ord a where ...  extends  Eq  Functor is similar to the Visitor-Pattern  The compiler can automatically generate default implementations for polymorphism with  deriving", 
            "title": "Polymorphism"
        }, 
        {
            "location": "/prfm/haskell_first-steps/#interactive-programming", 
            "text": "We need a way to input data with a keyboard and show data on a screen (side effects)  Side effects are integrated into the type system of Haskell  Basic Type:  IO a : The type of actions that return a value of type  a  Intuition: Function takes \"the world\" and returns it (possibly changed) along with a value  IO ()  is a type that returns no value  getChar  and  putChar  read and write characters from keyboard to screen  do  composes sequential actions together  return  returns a value in a  do  assignment with  x  - func", 
            "title": "Interactive Programming"
        }, 
        {
            "location": "/prfm/summary/", 
            "text": "Summary\n\n\nProlog\n\n\n\n\nVariables start with an uppercase letter\n\n\nAtoms are in \n''\n quotes or start with a lowercase letter\n\n\nArity\n is the number of arguments of a complex term\n\n\nPredicates with different arity are different (\"overloading\")\n\n\n\n\n\n\nTwo terms unify if either:\n\n\nthey are identical \n\n\nor can be instantiated uniformly such that the resulting terms are equal\n\n\n\n\n\n\nArithmetic: \n2 + 3 = 5\n -\n \n2+3 is 5\n\n\nSyntactic sugar for \nis(+(2,3),5)\n\n\n\n\n\n\n\n\nRecursion\n\n\n\n\nList recursion: \n[H|T]\n\n\nPrefer tail recursion (e.g. with accumulators), the search tree will be smaller\n\n\nin a recursive clause, base case should always come before the recursive \"call\", or it won't terminate!\n\n\n\n\nProof search\n\n\n\n\nCollecting Solutions\n\n\n\n\nFind all solutions from a goal for a specific object (here \nX\n and collect them in List \nL\n)\n\n\nAlways succeeds, empty List if no solutions found\n\n\nfindall (X, descend(martha,X), L).\n\n\n\n\n\n\n\n\nLambda Calculus\n\n\n\n\nApplication binds tighter than abstraction\n\n\n\n\n\\lambda x. M_1 M_2 \\Leftrightarrow \\lambda x. (M_1 M_2)\n\n\n\n\n\n\n\n\nApplication is left-associative\n\n\nA \n\\lambda\n term is in normal form if no further reductions can be applied to it\n\n\nEvery \nlambda\n term has \nat most\n one normal form (this makes computation deterministic)\n\n\n\n\n\n\n\n\n\\delta\n-reduction: substitution of a defined symbol with its definition\n\n\n\n\nStrategies\n\n\n\n\nInnermost-first\n: the innermost \nreducible expression\n (redex) first, i.e. there's no other redex inside it\n\n\nif ambiguous, the left-most first\n\n\nwith this strategy, function arguments are reduced exactly once\n\n\ncorresponds to \ncall by value\n\n\n\n\n\n\noutermost-first\n (normal form): the outermost redex first, i.e. there's no redex outside it\n\n\nif ambiguous, the left-most first\n\n\nAlways ends in a normal form\n\n\nwith this strategy, function arguments are reduced as many times as they're needed -\n unneeded arguments won't be reduced\n\n\ncorresponds to \ncall by name\n\n\n\n\n\n\n\n\nHaskell\n\n\nTypes\n\n\n\n\nInt\n has a fixed precision (64 bit), while \nInteger\n has an arbitrary precision\n\n\nFunction application is left-associative, while the type definition \nt1 -\n t2\n is \nright-associative\n\n\ntype\n declares a type as an alias of other types\n\n\nNo recursion allowed\n\n\nmay have parameters\n\n\nexample: \ntype Assoc k v = [(k,v)]\n\n\n\n\n\n\ndata\n declares a new type\n\n\nRecursive definitions possible\n\n\nwith type parameters: \ndata Shape = Circle Float | Rect Float Float\n\n\nif type has a single constructor, \nnewtype\n can be use for efficiency: \nnewtype Nat = N int\n\n\nexample: \ndata Tree a = Leaf a | Node (Tree a) a (Tree a)\n\n\n\n\n\n\n\n\nClasses\n\n\n\n\nlike an interface, defines what methods a type must have\n\n\ncan have default definitions\n\n\n\n\n1\n2\n3\nclass\n \nEq\n \na\n \nwhere\n\n    \n(\n==\n),\n \n(\n/=\n)\n \n::\n \na\n \n-\n \na\n \n-\n \nBool\n\n    \nx\n \n/=\n \ny\n \n=\n \nnot\n \n(\nx\n \n==\n \ny\n)\n \n-- default definition\n\n\n\n\n\n\n\n\n\nclasses can be extended: \nclass Eq a =\n Ord a where ...\n\n\nDefining instances:\n\n\n\n\n1\n2\n3\n4\ninstance\n \nEq\n \nBool\n \nwhere\n\n    \nFalse\n \n==\n \nFalse\n \n=\n \nTrue\n\n    \nTrue\n \n==\n \nTrue\n \n=\n \nTrue\n\n    \n_\n \n==\n \n_\n \n=\n \nFalse\n\n\n\n\n\n\n\n\n\ninstances can be defined directly inside the type definition \ndata\n with \nderiving\n\n\n\n\n1\n2\ndata\n \nBool\n \n=\n \nFalse\n \n|\n \nTrue\n \n-- order matters here, such that False \n True\n\n    \nderiving\n \n(\nEq\n,\n \nOrd\n,\n \nShow\n,\n \nRead\n)\n\n\n\n\n\n\n\nFunctions\n\n\n\n\nGuarded Equations (read \n|\n as \"such that\"):\n\n\n\n\n1\n2\nabs\n \nn\n \n|\n \nn\n \n=\n \n0\n    \n=\n \nn\n\n      \n|\n \notherwise\n \n=\n \n-\nn\n\n\n\n\n\n\n\n\n\ncons \n:\n is right-associative: \n1:2:3:[] == [1,2,3]\n\n\n\n\nFoldr / Foldl\n\n\n\n\nfoldr\n\n\n\n\n1\n2\n3\nfoldr\n \n::\n \n(\na\n \n-\n \nb\n \n-\n \nb\n)\n \n-\n \nb\n \n-\n \n[\na\n]\n \n-\n \nb\n\n\nfoldr\n \nf\n \nv\n \n[]\n \n=\n \nv\n\n\nfoldr\n \nf\n \nv\n \n(\nx\n \n:\nxs\n)\n \n=\n \nf\n \nx\n \n(\nfoldr\n \nf\n \nv\n \nxs\n)\n\n\n\n\n\n\n\n\n\nfoldl\n\n\n\n\n1\n2\n3\nfoldl\n \n::\n \n(\na\n \n-\n \nb\n \n-\n \na\n)\n \n-\n \na\n \n-\n \n[\nb\n]\n \n-\n \na\n\n\nfoldl\n \nf\n \nv\n \n[]\n \n=\n \nv\n\n\nfoldl\n \nf\n \nv\n \n(\nx\n \n:\nxs\n)\n \n=\n \nfold\n \nf\n \n(\nf\n \nv\n \nx\n)\n \nxs\n\n\n\n\n\n\n\n\n\nas non-recursive patterns:\n\n\n\n\n\n\n foldr \\, (\\#) \\, v \\, [x_0,x_1,\\ldots,x_n] = x_0 \\; \\# \\; (x_1\\, \\# \\, (\\ldots \\, (x_n \\, \\# \\, v) \\, \\ldots )) \n\n\n foldl \\, (\\#) \\, v \\, [x_0,x_1,\\ldots,x_n] = (\\ldots ((v \\, \\# \\, x_0) \\, \\# \\, x_1) \\; \\ldots) \\, \\# \\, x_n \n\n\n\n\nFunction composition\n\n\n\n\nf . g\n: Read \"f of g of ...\"\n\n\nf . g = \\x -\n f (g x)\n\n\n\n\nInteractive Programming\n\n\n\n\nIO\n is an built-in type\n\n\nModeled as \ntype IO a = \"world\" -\n (a, \"world\")\n, i.e. with side effects, \"impure\"\n\n\nSequencing\n\n\n\n\n1\n2\n3\n4\n5\nact\n \n::\n \nIO\n \n(\nChar\n,\nChar\n)\n\n\nact\n \n=\n \ndo\n \nx\n \n-\n \ngetChar\n\n         \ngetChar\n \n-- result discarded\n\n         \ny\n \n-\n \ngetChar\n\n         \nreturn\n \n(\nx\n,\ny\n)\n\n\n\n\n\n\n\nFunctors\n\n\n\n\nFunctors abstract the idea of \nmap\n to a general \nfmap\n\n\ne.g. with \nMaybe\n: \nfmap g (Just x) = Just (g x)\n\n\nApplies a function to the inner elements of a data struture\n\n\n\n\nApplicatives\n\n\n\n\nExtends \nFunctor\n\n\nExtends the concept of \nfmap\n to an arbitrary amount of function arguments (whereas \nfmap\n just takes 1 function)\n\n\n\n\n1\n2\n3\nclass\n \nFunctor\n \nf\n \n=\n \nApplicative\n \nf\n \nwhere\n\n    \npure\n \n::\n \na\n \n-\n \nf\n \na\n\n    \n(\n*\n)\n \n::\n \nf\n \n(\na\n \n-\n \nb\n)\n \n-\n \nf\n \na\n \n-\n \nf\n \nb\n\n\n\n\n\n\n\n\n\nApplicative form: \npure g \n*\n x1 \n*\n ... \n*\n xn\n\n\ng\n takes \nn\n arguments\n\n\ne.g. \npure (+1) \n*\n [1,2] = [2,3]\n = \nfmap (+1) [1,2]\n\n\n\n\nMonads\n\n\n\n\nAllows the \ndo\n notation\n\n\nExtends \nApplicative\n with a \"bind\"-operator \n=\n\n\n(\n=) :: m a -\n (a -\n m b) -\n m b\n\n\n\n\n\n\nreturn = pure\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\neval\n \n(\nVal\n \nn\n)\n \n=\n \nJust\n \nn\n \n-- applicative `pure` of Maybe is `just`\n\n\neval\n \n(\nDiv\n \nx\n \ny\n)\n \n=\n \neval\n \nx\n \n=\n \n\\\nn\n \n-\n \n-- n is the result of eval x\n\n                 \neval\n \ny\n \n=\n \n\\\nm\n \n-\n\n                 \nsafediv\n \nn\n \nm\n\n\n\n-- equivalent to --\n\n\neval\n \n(\nDiv\n \nx\n \ny\n)\n \n=\n \ndo\n \nn\n \n-\n \neval\n \nx\n\n                    \nm\n \n-\n \neval\n \ny\n\n                    \nsavediv\n \nn\n \nm", 
            "title": "Summary"
        }, 
        {
            "location": "/prfm/summary/#summary", 
            "text": "", 
            "title": "Summary"
        }, 
        {
            "location": "/prfm/summary/#prolog", 
            "text": "Variables start with an uppercase letter  Atoms are in  ''  quotes or start with a lowercase letter  Arity  is the number of arguments of a complex term  Predicates with different arity are different (\"overloading\")    Two terms unify if either:  they are identical   or can be instantiated uniformly such that the resulting terms are equal    Arithmetic:  2 + 3 = 5  -   2+3 is 5  Syntactic sugar for  is(+(2,3),5)", 
            "title": "Prolog"
        }, 
        {
            "location": "/prfm/summary/#recursion", 
            "text": "List recursion:  [H|T]  Prefer tail recursion (e.g. with accumulators), the search tree will be smaller  in a recursive clause, base case should always come before the recursive \"call\", or it won't terminate!", 
            "title": "Recursion"
        }, 
        {
            "location": "/prfm/summary/#proof-search", 
            "text": "", 
            "title": "Proof search"
        }, 
        {
            "location": "/prfm/summary/#collecting-solutions", 
            "text": "Find all solutions from a goal for a specific object (here  X  and collect them in List  L )  Always succeeds, empty List if no solutions found  findall (X, descend(martha,X), L).", 
            "title": "Collecting Solutions"
        }, 
        {
            "location": "/prfm/summary/#lambda-calculus", 
            "text": "Application binds tighter than abstraction   \\lambda x. M_1 M_2 \\Leftrightarrow \\lambda x. (M_1 M_2)     Application is left-associative  A  \\lambda  term is in normal form if no further reductions can be applied to it  Every  lambda  term has  at most  one normal form (this makes computation deterministic)     \\delta -reduction: substitution of a defined symbol with its definition", 
            "title": "Lambda Calculus"
        }, 
        {
            "location": "/prfm/summary/#strategies", 
            "text": "Innermost-first : the innermost  reducible expression  (redex) first, i.e. there's no other redex inside it  if ambiguous, the left-most first  with this strategy, function arguments are reduced exactly once  corresponds to  call by value    outermost-first  (normal form): the outermost redex first, i.e. there's no redex outside it  if ambiguous, the left-most first  Always ends in a normal form  with this strategy, function arguments are reduced as many times as they're needed -  unneeded arguments won't be reduced  corresponds to  call by name", 
            "title": "Strategies"
        }, 
        {
            "location": "/prfm/summary/#haskell", 
            "text": "", 
            "title": "Haskell"
        }, 
        {
            "location": "/prfm/summary/#types", 
            "text": "Int  has a fixed precision (64 bit), while  Integer  has an arbitrary precision  Function application is left-associative, while the type definition  t1 -  t2  is  right-associative  type  declares a type as an alias of other types  No recursion allowed  may have parameters  example:  type Assoc k v = [(k,v)]    data  declares a new type  Recursive definitions possible  with type parameters:  data Shape = Circle Float | Rect Float Float  if type has a single constructor,  newtype  can be use for efficiency:  newtype Nat = N int  example:  data Tree a = Leaf a | Node (Tree a) a (Tree a)", 
            "title": "Types"
        }, 
        {
            "location": "/prfm/summary/#classes", 
            "text": "like an interface, defines what methods a type must have  can have default definitions   1\n2\n3 class   Eq   a   where \n     ( == ),   ( /= )   ::   a   -   a   -   Bool \n     x   /=   y   =   not   ( x   ==   y )   -- default definition     classes can be extended:  class Eq a =  Ord a where ...  Defining instances:   1\n2\n3\n4 instance   Eq   Bool   where \n     False   ==   False   =   True \n     True   ==   True   =   True \n     _   ==   _   =   False     instances can be defined directly inside the type definition  data  with  deriving   1\n2 data   Bool   =   False   |   True   -- order matters here, such that False   True \n     deriving   ( Eq ,   Ord ,   Show ,   Read )", 
            "title": "Classes"
        }, 
        {
            "location": "/prfm/summary/#functions", 
            "text": "Guarded Equations (read  |  as \"such that\"):   1\n2 abs   n   |   n   =   0      =   n \n       |   otherwise   =   - n     cons  :  is right-associative:  1:2:3:[] == [1,2,3]", 
            "title": "Functions"
        }, 
        {
            "location": "/prfm/summary/#foldr-foldl", 
            "text": "foldr   1\n2\n3 foldr   ::   ( a   -   b   -   b )   -   b   -   [ a ]   -   b  foldr   f   v   []   =   v  foldr   f   v   ( x   : xs )   =   f   x   ( foldr   f   v   xs )     foldl   1\n2\n3 foldl   ::   ( a   -   b   -   a )   -   a   -   [ b ]   -   a  foldl   f   v   []   =   v  foldl   f   v   ( x   : xs )   =   fold   f   ( f   v   x )   xs     as non-recursive patterns:     foldr \\, (\\#) \\, v \\, [x_0,x_1,\\ldots,x_n] = x_0 \\; \\# \\; (x_1\\, \\# \\, (\\ldots \\, (x_n \\, \\# \\, v) \\, \\ldots ))    foldl \\, (\\#) \\, v \\, [x_0,x_1,\\ldots,x_n] = (\\ldots ((v \\, \\# \\, x_0) \\, \\# \\, x_1) \\; \\ldots) \\, \\# \\, x_n", 
            "title": "Foldr / Foldl"
        }, 
        {
            "location": "/prfm/summary/#function-composition", 
            "text": "f . g : Read \"f of g of ...\"  f . g = \\x -  f (g x)", 
            "title": "Function composition"
        }, 
        {
            "location": "/prfm/summary/#interactive-programming", 
            "text": "IO  is an built-in type  Modeled as  type IO a = \"world\" -  (a, \"world\") , i.e. with side effects, \"impure\"  Sequencing   1\n2\n3\n4\n5 act   ::   IO   ( Char , Char )  act   =   do   x   -   getChar \n          getChar   -- result discarded \n          y   -   getChar \n          return   ( x , y )", 
            "title": "Interactive Programming"
        }, 
        {
            "location": "/prfm/summary/#functors", 
            "text": "Functors abstract the idea of  map  to a general  fmap  e.g. with  Maybe :  fmap g (Just x) = Just (g x)  Applies a function to the inner elements of a data struture", 
            "title": "Functors"
        }, 
        {
            "location": "/prfm/summary/#applicatives", 
            "text": "Extends  Functor  Extends the concept of  fmap  to an arbitrary amount of function arguments (whereas  fmap  just takes 1 function)   1\n2\n3 class   Functor   f   =   Applicative   f   where \n     pure   ::   a   -   f   a \n     ( * )   ::   f   ( a   -   b )   -   f   a   -   f   b     Applicative form:  pure g  *  x1  *  ...  *  xn  g  takes  n  arguments  e.g.  pure (+1)  *  [1,2] = [2,3]  =  fmap (+1) [1,2]", 
            "title": "Applicatives"
        }, 
        {
            "location": "/prfm/summary/#monads", 
            "text": "Allows the  do  notation  Extends  Applicative  with a \"bind\"-operator  =  ( =) :: m a -  (a -  m b) -  m b    return = pure   1\n2\n3\n4\n5\n6\n7\n8\n9 eval   ( Val   n )   =   Just   n   -- applicative `pure` of Maybe is `just`  eval   ( Div   x   y )   =   eval   x   =   \\ n   -   -- n is the result of eval x \n                  eval   y   =   \\ m   - \n                  safediv   n   m  -- equivalent to --  eval   ( Div   x   y )   =   do   n   -   eval   x \n                     m   -   eval   y \n                     savediv   n   m", 
            "title": "Monads"
        }, 
        {
            "location": "/pmqm/", 
            "text": "Projekt- und Qualit\u00e4tsmanagement", 
            "title": "Index"
        }, 
        {
            "location": "/pmqm/#projekt-und-qualitatsmanagement", 
            "text": "", 
            "title": "Projekt- und Qualit\u00e4tsmanagement"
        }, 
        {
            "location": "/pmqm/exam/", 
            "text": "Exam\n\n\n\n\nOpen Book mit Laptop\n\n\n\n\nNotes Q\nA\n\n\n\n\n\n\nLiteraturliste anschauen\n\n\n\n\nB\u00fccher herunterladen\n\n\nu.A. ITIL-Buch\n\n\n\n\n\n\n\n\nRUP, Kanban, Scrum nur oberfl\u00e4chlich\n\n\n\n\nScrum guide auf deutsch und englisch herunterladen\n\n\nEVA und ROI kommen sicher (Excel Vorlagen!)\n\n\nSYSIGMA anschauen\n\n\n\n\nInhalt\n\n\n\n\nCPI muss optimalerweise 1 sein\n\n\n\n\n\n\n1 besser als geplant, \n1 schlechter als geplant\n\n\n\n\n\n\n\n\n\n\n\n\nPr\u00fcfung 2017\n\n\n\n\n1.13: Max Ausfallzeit ist von vorherein bekannt, bei CPI schaut man immer in Vergangenheit\n\n\n1.11: Spielt nicht Polizist", 
            "title": "Exam"
        }, 
        {
            "location": "/pmqm/exam/#exam", 
            "text": "Open Book mit Laptop", 
            "title": "Exam"
        }, 
        {
            "location": "/pmqm/exam/#notes-qa", 
            "text": "Literaturliste anschauen   B\u00fccher herunterladen  u.A. ITIL-Buch     RUP, Kanban, Scrum nur oberfl\u00e4chlich   Scrum guide auf deutsch und englisch herunterladen  EVA und ROI kommen sicher (Excel Vorlagen!)  SYSIGMA anschauen", 
            "title": "Notes Q&amp;A"
        }, 
        {
            "location": "/pmqm/exam/#inhalt", 
            "text": "CPI muss optimalerweise 1 sein    1 besser als geplant,  1 schlechter als geplant", 
            "title": "Inhalt"
        }, 
        {
            "location": "/pmqm/exam/#prufung-2017", 
            "text": "1.13: Max Ausfallzeit ist von vorherein bekannt, bei CPI schaut man immer in Vergangenheit  1.11: Spielt nicht Polizist", 
            "title": "Pr\u00fcfung 2017"
        }, 
        {
            "location": "/pmqm/projekt_qualitaet/", 
            "text": "Projekt und Qualit\u00e4t\n\n\n\n\nWichtig: Qualit\u00e4tsrelevante Interessen kennen!\n\n\n\n\nPlan, Do, Check, Act\n\n\n\n\nPlan - SMART-Ziele\n\n\nSpezifisch, Messbar, Akzeptiert, Realistisch, Terminiert\n\n\n\n\n\n\nDo - OTOBOS\n\n\nOn Time, on Budget, on Scope", 
            "title": "Projekt und Qualit\u00e4t"
        }, 
        {
            "location": "/pmqm/projekt_qualitaet/#projekt-und-qualitat", 
            "text": "Wichtig: Qualit\u00e4tsrelevante Interessen kennen!", 
            "title": "Projekt und Qualit\u00e4t"
        }, 
        {
            "location": "/pmqm/projekt_qualitaet/#plan-do-check-act", 
            "text": "Plan - SMART-Ziele  Spezifisch, Messbar, Akzeptiert, Realistisch, Terminiert    Do - OTOBOS  On Time, on Budget, on Scope", 
            "title": "Plan, Do, Check, Act"
        }, 
        {
            "location": "/pmqm/projekte/", 
            "text": "Projekte\n\n\nProjekttypen\n\n\n\n\nLinienprojekt: Alle wichtigen Akteure sind in ihrer Stammorganisation (Chef = PL)\n\n\nKleine Projekte, Startups\n\n\n\n\n\n\nMatrixorganisation: Akteure sind in verschiedenen Einheiten (Entwicklung, Verkauf, etc.)\n\n\nPL ist aus Pool und \"normaler\" Mitarbeiter\n\n\nF\u00fcr grosse Unternehmen\n\n\n\n\n\n\nStablinienorganisation: Gleich wie Matrix, aber PL ist aus Stabsstelle\n\n\nZ.B. mit externem PL\n\n\nFlexible L\u00f6sung f\u00fcr mittelgrosse Projekte\n\n\n\n\n\n\nReine Projektorganisation: Alle wichtigen Akteure werden in die gleiche Einheit zusammen gezogen (Einehitsleiter = PL)\n\n\nF\u00fcr grosse Projekte mit langfristigem Fokus\n\n\n\n\n\n\n\n\nRequirement Engineering\n\n\n\n\nNormalerweise Anforderungen \"Soll\" einteilen, f\u00fcr ganz wichtiges \"Muss\"\n\n\n\n\nLernkontrolle\n\n\n\n\nFrage 2: C und D sind falsch\n\n\nFrage 3: Interviews, Beobachtung", 
            "title": "Projekte"
        }, 
        {
            "location": "/pmqm/projekte/#projekte", 
            "text": "", 
            "title": "Projekte"
        }, 
        {
            "location": "/pmqm/projekte/#projekttypen", 
            "text": "Linienprojekt: Alle wichtigen Akteure sind in ihrer Stammorganisation (Chef = PL)  Kleine Projekte, Startups    Matrixorganisation: Akteure sind in verschiedenen Einheiten (Entwicklung, Verkauf, etc.)  PL ist aus Pool und \"normaler\" Mitarbeiter  F\u00fcr grosse Unternehmen    Stablinienorganisation: Gleich wie Matrix, aber PL ist aus Stabsstelle  Z.B. mit externem PL  Flexible L\u00f6sung f\u00fcr mittelgrosse Projekte    Reine Projektorganisation: Alle wichtigen Akteure werden in die gleiche Einheit zusammen gezogen (Einehitsleiter = PL)  F\u00fcr grosse Projekte mit langfristigem Fokus", 
            "title": "Projekttypen"
        }, 
        {
            "location": "/pmqm/projekte/#requirement-engineering", 
            "text": "Normalerweise Anforderungen \"Soll\" einteilen, f\u00fcr ganz wichtiges \"Muss\"", 
            "title": "Requirement Engineering"
        }, 
        {
            "location": "/pmqm/projekte/#lernkontrolle", 
            "text": "Frage 2: C und D sind falsch  Frage 3: Interviews, Beobachtung", 
            "title": "Lernkontrolle"
        }, 
        {
            "location": "/pmqm/finanzen/", 
            "text": "Finanzen\n\n\nDiskontierung\n\n\n\n\nQuasi interner \"Zinssatz\" + Risiko, der f\u00fcr jedes Jahr in der Zukunft aufaddiert wird, um die Unberechenbarkeit der Zukunft einzuberechnen\n\n\nz.B. Diskontierungsfaktor 4.5%: \nJahresgewinn * (1-(Jahr * 4.5%))\n\n\n\n\nFinanzierung\n\n\n\n\nDie meisten Projekte brauchen zuerst eine interne Finanzierung, auch wenn der gr\u00f6sste Teil danach extern finanziert wird", 
            "title": "Finanzen"
        }, 
        {
            "location": "/pmqm/finanzen/#finanzen", 
            "text": "", 
            "title": "Finanzen"
        }, 
        {
            "location": "/pmqm/finanzen/#diskontierung", 
            "text": "Quasi interner \"Zinssatz\" + Risiko, der f\u00fcr jedes Jahr in der Zukunft aufaddiert wird, um die Unberechenbarkeit der Zukunft einzuberechnen  z.B. Diskontierungsfaktor 4.5%:  Jahresgewinn * (1-(Jahr * 4.5%))", 
            "title": "Diskontierung"
        }, 
        {
            "location": "/pmqm/finanzen/#finanzierung", 
            "text": "Die meisten Projekte brauchen zuerst eine interne Finanzierung, auch wenn der gr\u00f6sste Teil danach extern finanziert wird", 
            "title": "Finanzierung"
        }, 
        {
            "location": "/apparch/", 
            "text": "Application Architecture", 
            "title": "Index"
        }, 
        {
            "location": "/apparch/#application-architecture", 
            "text": "", 
            "title": "Application Architecture"
        }, 
        {
            "location": "/apparch/architecture_fundamentals/", 
            "text": "Softare Architecture Fundamentals\n\n\nDefintion\n\n\n\n\nSoftware Architect ist eine Rolle  mit vielen Disziplinen (consult, create, maintain, review, ...)\n\n\nKann in agiler Entwicklung auch eine \"virtuelle\" Rolle sein\n\n\n\n\nPhasen\n\n\n\n\n\"Architectural Concerns\" - Architekturanforderungen und -interessen\n\n\nArchitectural Analysis - \"Requirements engineering\"\n\n\nArchitectural Synthesis - \"Architektur Design\"\n\n\nArchitectural Evaluation - \"Architektur-Review\"\n\n\n\n\nArchitectural Significance\n\n\n\n\nEconomic Significance: z.B. \"Kann damit der Vertrag erf\u00fcllt werden?\", \"Konkurenz hat dies bereits, brauchen wir auch\"\n\n\nOft entscheidet auch die Erfahrung aus fr\u00fcheren Projekten, ob Requirements f\u00fcr die Architektur relevant sind\n\n\nAndere Checkliste von P. Eeles:\n\n\nungenau definiert, was heisst \"critical\" functionality?\n\n\nDie meisten Anforderungen treffen nach dieser Checkliste zu\n\n\n\n\n\n\n\n\nViewpoints\n\n\n\n\nEin Viewpoint gruppiert Anliegen (concerns) von Stakeholdern\n\n\n\n\n4+1 Viewpoint Model (RUP)\n\n\n\n\nView f\u00fcr Logical (f\u00fcr Designer), Implementation (f\u00fcr Programmer), Process (f\u00fcr Integrators) und Deployment\n\n\nUse-case View in der Mitte, die alles verbindet", 
            "title": "Fundamentals"
        }, 
        {
            "location": "/apparch/architecture_fundamentals/#softare-architecture-fundamentals", 
            "text": "", 
            "title": "Softare Architecture Fundamentals"
        }, 
        {
            "location": "/apparch/architecture_fundamentals/#defintion", 
            "text": "Software Architect ist eine Rolle  mit vielen Disziplinen (consult, create, maintain, review, ...)  Kann in agiler Entwicklung auch eine \"virtuelle\" Rolle sein", 
            "title": "Defintion"
        }, 
        {
            "location": "/apparch/architecture_fundamentals/#phasen", 
            "text": "\"Architectural Concerns\" - Architekturanforderungen und -interessen  Architectural Analysis - \"Requirements engineering\"  Architectural Synthesis - \"Architektur Design\"  Architectural Evaluation - \"Architektur-Review\"", 
            "title": "Phasen"
        }, 
        {
            "location": "/apparch/architecture_fundamentals/#architectural-significance", 
            "text": "Economic Significance: z.B. \"Kann damit der Vertrag erf\u00fcllt werden?\", \"Konkurenz hat dies bereits, brauchen wir auch\"  Oft entscheidet auch die Erfahrung aus fr\u00fcheren Projekten, ob Requirements f\u00fcr die Architektur relevant sind  Andere Checkliste von P. Eeles:  ungenau definiert, was heisst \"critical\" functionality?  Die meisten Anforderungen treffen nach dieser Checkliste zu", 
            "title": "Architectural Significance"
        }, 
        {
            "location": "/apparch/architecture_fundamentals/#viewpoints", 
            "text": "Ein Viewpoint gruppiert Anliegen (concerns) von Stakeholdern", 
            "title": "Viewpoints"
        }, 
        {
            "location": "/apparch/architecture_fundamentals/#41-viewpoint-model-rup", 
            "text": "View f\u00fcr Logical (f\u00fcr Designer), Implementation (f\u00fcr Programmer), Process (f\u00fcr Integrators) und Deployment  Use-case View in der Mitte, die alles verbindet", 
            "title": "4+1 Viewpoint Model (RUP)"
        }, 
        {
            "location": "/apparch/agile_architecture/", 
            "text": "Agile Architecture \n Quality Attribute-Driven Design\n\n\nDiscussion\n\n\n\n\nApplication Architecture: Spezifisch auf Ebene \"Logical View\" und \"Development View\"\n\n\nSpezialisierung von \"Software Architecture\", das die ganze Disziplin umfasst\n\n\n\n\n\n\n\n\nAgile Architecting\n\n\n\n\nz.B. Tags auf Issues erstellen f\u00fcr ASR-Kategorisierung\n\n\nProzesse geben Notationen vor (wie Use case diagram)\n\n\nAgile Modeling: Viel auf Whiteboard, pragmatisch\n\n\nAttribute-Driven Design: Aus Quality-Attributes die Architektur entwerfen\n\n\nPatterns und Frameworks werden ausgew\u00e4hlt\n\n\n\n\n\n\n\n\nNFRs\n\n\n\n\nSMART - Specific, Measurable, Agreed, Realistic, Time-bound\n\n\nFURPS: Functionality, Usability, Reliability, Performance, Supportability (\"Betreibbarkeit\")\n\n\nTaxonomy: Begriffe anbringen und diese in Beziehung zueinander setzen\n\n\nSystem: Requirements: Zu Attributes (FURPS, NFR) kommen auch Constraints (z.B. politische, rechtliche) und Functional Requirements\n\n\nTaxonomonien helfen auch bei Reviews, um einen \u00dcberblick zu behalten\n\n\n\n\nQuality Attribute Scenario\n\n\n\n\nEnvironment: z.B. \"Runtime\" oder \"Buildtime\"\n\n\nArtifact: Welche Dokumente / Systeme sind betroffen?\n\n\nWICHTIG\n: Response Measure: Wie wird das Resultat gemessen? Was muss diese Messung erf\u00fcllen?\n\n\n\n\nUser Story Template\n\n\n\n\nUser STories erg\u00e4nzen mit \"to achieve this goal, ...\"\n\n\nNFRs und andere messbare Ziele\n\n\nAlternative zu usability Ziele (more agile): A/B-Testing, mit User im Projekt direkt testen\n\n\nErweiterung \"Quality Story Template\" f\u00fcr System Administratoren\n\n\n\"As a system administrator, i would like [NFR]\"\n\n\n\"To achieve this goal, i'm willing to accept/invest ...\"", 
            "title": "Agile Architecture"
        }, 
        {
            "location": "/apparch/agile_architecture/#agile-architecture-quality-attribute-driven-design", 
            "text": "", 
            "title": "Agile Architecture &amp; Quality Attribute-Driven Design"
        }, 
        {
            "location": "/apparch/agile_architecture/#discussion", 
            "text": "Application Architecture: Spezifisch auf Ebene \"Logical View\" und \"Development View\"  Spezialisierung von \"Software Architecture\", das die ganze Disziplin umfasst", 
            "title": "Discussion"
        }, 
        {
            "location": "/apparch/agile_architecture/#agile-architecting", 
            "text": "z.B. Tags auf Issues erstellen f\u00fcr ASR-Kategorisierung  Prozesse geben Notationen vor (wie Use case diagram)  Agile Modeling: Viel auf Whiteboard, pragmatisch  Attribute-Driven Design: Aus Quality-Attributes die Architektur entwerfen  Patterns und Frameworks werden ausgew\u00e4hlt", 
            "title": "Agile Architecting"
        }, 
        {
            "location": "/apparch/agile_architecture/#nfrs", 
            "text": "SMART - Specific, Measurable, Agreed, Realistic, Time-bound  FURPS: Functionality, Usability, Reliability, Performance, Supportability (\"Betreibbarkeit\")  Taxonomy: Begriffe anbringen und diese in Beziehung zueinander setzen  System: Requirements: Zu Attributes (FURPS, NFR) kommen auch Constraints (z.B. politische, rechtliche) und Functional Requirements  Taxonomonien helfen auch bei Reviews, um einen \u00dcberblick zu behalten", 
            "title": "NFRs"
        }, 
        {
            "location": "/apparch/agile_architecture/#quality-attribute-scenario", 
            "text": "Environment: z.B. \"Runtime\" oder \"Buildtime\"  Artifact: Welche Dokumente / Systeme sind betroffen?  WICHTIG : Response Measure: Wie wird das Resultat gemessen? Was muss diese Messung erf\u00fcllen?", 
            "title": "Quality Attribute Scenario"
        }, 
        {
            "location": "/apparch/agile_architecture/#user-story-template", 
            "text": "User STories erg\u00e4nzen mit \"to achieve this goal, ...\"  NFRs und andere messbare Ziele  Alternative zu usability Ziele (more agile): A/B-Testing, mit User im Projekt direkt testen  Erweiterung \"Quality Story Template\" f\u00fcr System Administratoren  \"As a system administrator, i would like [NFR]\"  \"To achieve this goal, i'm willing to accept/invest ...\"", 
            "title": "User Story Template"
        }, 
        {
            "location": "/apparch/solution_strategy/", 
            "text": "Solution Strategy\n\n\nTipps f\u00fcr Solution Strategy: \nhttp://docs.arc42.org/keywords/#solution-strategy\n\n\nArchitectural Synthesis\n\n\n\n\nScope abstecken mit funktionalen Komponenten und externen Interfaces\n\n\nWichtige Entscheidungen zur Architektur (Tiers, Frameworks)\n\n\n\"Twin Peaks Model\": Requirements und Design (Architektur) werden \"gleichzeitig\" ausgearbeitet (iterativ und inkrementell)\n\n\n\n\nLayer-Pattern\n\n\n\n\nIm Layer-Pattern gibt es keine Layer-\"Spr\u00fcnge\"!\n\n\nLayers sind logisch und geben nicht die physikalische Verteilung (tiers) vor\n\n\n\"Enterprise Resources\" = \"Domain Entities\"\n\n\nBusiness Rule: Anforderungen, z.B. \"Kundenanfragen werden in x Min beantwortet\"\n\n\n\n\nClient-Server Cuts\n\n\n\n\nLayer-Pattern zwei mal angewendet: Logisch (logical Viewpoint) und Aufteilung auf phyiskalische Tiers (deployment viewpoint)\n\n\nLayer k\u00f6nnen als ganzes auf Tiers aufgeteilt werden, oder Layer k\u00f6nnen auch \"geschnitten\" werden\n\n\nTiers und Layers werden oft missverst\u00e4ndlich verwendet, am besten immer nachfragen\n\n\nFliessende Layers: Ist z.B. Eingabevalidierung im Presentation-Layer, oder allein / zus\u00e4tzlich noch in Business Logic?\n\n\nz.B. auf beiden Layern testen und mit Tests \"synchronisieren\"\n\n\n\n\n\n\n\n\nC4 Models\n\n\n\n\nContext\n: System ist black-box, welche Schnittstellen kommunizieren damit?\n\n\nDazu geh\u00f6ren andere Systeme und auch User mit Use Cases\n\n\n\n\n\n\nContainer\n: Gibt eine \u00dcbersicht der Architektur (solution strateby)\n\n\nHigh-Level Technology choices\n\n\n\n\n\n\nComponents\n: Logische Komponenten und Kommunikation innerhalb eines Containers (mehr in n\u00e4chster Vorlesung)\n\n\nClasses\n (or Code): Klassendiagramm oder Code selbst", 
            "title": "Solution Strategy"
        }, 
        {
            "location": "/apparch/solution_strategy/#solution-strategy", 
            "text": "Tipps f\u00fcr Solution Strategy:  http://docs.arc42.org/keywords/#solution-strategy", 
            "title": "Solution Strategy"
        }, 
        {
            "location": "/apparch/solution_strategy/#architectural-synthesis", 
            "text": "Scope abstecken mit funktionalen Komponenten und externen Interfaces  Wichtige Entscheidungen zur Architektur (Tiers, Frameworks)  \"Twin Peaks Model\": Requirements und Design (Architektur) werden \"gleichzeitig\" ausgearbeitet (iterativ und inkrementell)", 
            "title": "Architectural Synthesis"
        }, 
        {
            "location": "/apparch/solution_strategy/#layer-pattern", 
            "text": "Im Layer-Pattern gibt es keine Layer-\"Spr\u00fcnge\"!  Layers sind logisch und geben nicht die physikalische Verteilung (tiers) vor  \"Enterprise Resources\" = \"Domain Entities\"  Business Rule: Anforderungen, z.B. \"Kundenanfragen werden in x Min beantwortet\"", 
            "title": "Layer-Pattern"
        }, 
        {
            "location": "/apparch/solution_strategy/#client-server-cuts", 
            "text": "Layer-Pattern zwei mal angewendet: Logisch (logical Viewpoint) und Aufteilung auf phyiskalische Tiers (deployment viewpoint)  Layer k\u00f6nnen als ganzes auf Tiers aufgeteilt werden, oder Layer k\u00f6nnen auch \"geschnitten\" werden  Tiers und Layers werden oft missverst\u00e4ndlich verwendet, am besten immer nachfragen  Fliessende Layers: Ist z.B. Eingabevalidierung im Presentation-Layer, oder allein / zus\u00e4tzlich noch in Business Logic?  z.B. auf beiden Layern testen und mit Tests \"synchronisieren\"", 
            "title": "Client-Server Cuts"
        }, 
        {
            "location": "/apparch/solution_strategy/#c4-models", 
            "text": "Context : System ist black-box, welche Schnittstellen kommunizieren damit?  Dazu geh\u00f6ren andere Systeme und auch User mit Use Cases    Container : Gibt eine \u00dcbersicht der Architektur (solution strateby)  High-Level Technology choices    Components : Logische Komponenten und Kommunikation innerhalb eines Containers (mehr in n\u00e4chster Vorlesung)  Classes  (or Code): Klassendiagramm oder Code selbst", 
            "title": "C4 Models"
        }, 
        {
            "location": "/apparch/component_modeling/", 
            "text": "Component Modeling / Reference Architectures\n\n\nContainer Diagram\n\n\n\n\nContainer Diagram zeigt eine h\u00f6here Abstraktionsebene als das Komponenten-Diagramm\n\n\nJeder Container ist sepparat \"deployable\", z.B. Fileserver, file system, web app\n\n\n\n\n\n\nJeder Container kann in einzelne Components unterteilt werden\n\n\n\n\nComponent Modeling\n\n\n\n\nIn fr\u00fchen Phasen werden Komponenten erst tempor\u00e4r festgelegt, Komponenten heissen hier \"candidate components\"\n\n\nBuy vs. build (kann auch OS-Funktion wie Cron sein)\n\n\n\n\nComponent Identification\n\n\n\n\nKandidaten identifizieren\n\n\nF\u00fcr jede Rolle (Actor) im System eine Channel-Komponente\n\n\nF\u00fcr jedes Features pro Layer eine Komponente (z.B. \nNumberPortingPresentation\n)\n\n\n\n\n\n\nCRC brainstorming\n\n\nF\u00fcr jede Komponente Responsibilities und Collaborators (Interfaces) aufschreiben\n\n\nAusserdem: Welche Technologien k\u00f6nnen eingesetzt werden, was kann als Vorlage / Inspiration genommen werden?\n\n\n\n\n\n\nRefactoring\n\n\nz.B. Split / Merge Components\n\n\nNFA / Implementation beachten (erst jetzt)\n\n\nM\u00f6gliche Technologien\n\n\n\n\n\n\n\n\nArchitectural Styles\n\n\n\n\nAnalog Geb\u00e4ude-Architektur (Gothisch, Romanisch)\n\n\nz.B. \"client/server\", \"Layering\"", 
            "title": "Component Modeling"
        }, 
        {
            "location": "/apparch/component_modeling/#component-modeling-reference-architectures", 
            "text": "", 
            "title": "Component Modeling / Reference Architectures"
        }, 
        {
            "location": "/apparch/component_modeling/#container-diagram", 
            "text": "Container Diagram zeigt eine h\u00f6here Abstraktionsebene als das Komponenten-Diagramm  Jeder Container ist sepparat \"deployable\", z.B. Fileserver, file system, web app    Jeder Container kann in einzelne Components unterteilt werden", 
            "title": "Container Diagram"
        }, 
        {
            "location": "/apparch/component_modeling/#component-modeling", 
            "text": "In fr\u00fchen Phasen werden Komponenten erst tempor\u00e4r festgelegt, Komponenten heissen hier \"candidate components\"  Buy vs. build (kann auch OS-Funktion wie Cron sein)", 
            "title": "Component Modeling"
        }, 
        {
            "location": "/apparch/component_modeling/#component-identification", 
            "text": "Kandidaten identifizieren  F\u00fcr jede Rolle (Actor) im System eine Channel-Komponente  F\u00fcr jedes Features pro Layer eine Komponente (z.B.  NumberPortingPresentation )    CRC brainstorming  F\u00fcr jede Komponente Responsibilities und Collaborators (Interfaces) aufschreiben  Ausserdem: Welche Technologien k\u00f6nnen eingesetzt werden, was kann als Vorlage / Inspiration genommen werden?    Refactoring  z.B. Split / Merge Components  NFA / Implementation beachten (erst jetzt)  M\u00f6gliche Technologien", 
            "title": "Component Identification"
        }, 
        {
            "location": "/apparch/component_modeling/#architectural-styles", 
            "text": "Analog Geb\u00e4ude-Architektur (Gothisch, Romanisch)  z.B. \"client/server\", \"Layering\"", 
            "title": "Architectural Styles"
        }, 
        {
            "location": "/apparch/component_dynamics_container_patterns/", 
            "text": "Component Dynamics \n Container Patterns\n\n\n\n\nINSIEME nach 12 Jahren und 100 Mio. abgebrochen\n\n\n\n\nComponent Dynamics\n\n\n\n\nCandidate Components sind logische Komponenten der Architektur, die \u00e4hnliche Verantwortlichkeiten zusammen fassen\n\n\nImplementation Components sind aus dem Development Viewpoint, dies sind die konkreten Implementation mit deren Interfaces\n\n\nBei der Architektur geht es auch um den Fluss, d.h. um das Verhalten des Systems, nicht nur deren Struktur\n\n\n\n\nContainer Patterns\n\n\nPlugin\n\n\n\n\nz.B. Eclipse, Browser\n\n\nFunktionen werden durch Konfiguration (ohne Neukompilieren) hinzugef\u00fcgt\n\n\n\n\nInversion of Control\n\n\n\n\nFrameworks steuern den Fluss selber, Komponenten werden  vom Framework aufgerufen\n\n\nProblem: Wie wird definiert, wie Frameworks die Komponenten finden kann?\n\n\n-\n Dependency Injection", 
            "title": "Component Dynamics & Container Patterns"
        }, 
        {
            "location": "/apparch/component_dynamics_container_patterns/#component-dynamics-container-patterns", 
            "text": "INSIEME nach 12 Jahren und 100 Mio. abgebrochen", 
            "title": "Component Dynamics &amp; Container Patterns"
        }, 
        {
            "location": "/apparch/component_dynamics_container_patterns/#component-dynamics", 
            "text": "Candidate Components sind logische Komponenten der Architektur, die \u00e4hnliche Verantwortlichkeiten zusammen fassen  Implementation Components sind aus dem Development Viewpoint, dies sind die konkreten Implementation mit deren Interfaces  Bei der Architektur geht es auch um den Fluss, d.h. um das Verhalten des Systems, nicht nur deren Struktur", 
            "title": "Component Dynamics"
        }, 
        {
            "location": "/apparch/component_dynamics_container_patterns/#container-patterns", 
            "text": "", 
            "title": "Container Patterns"
        }, 
        {
            "location": "/apparch/component_dynamics_container_patterns/#plugin", 
            "text": "z.B. Eclipse, Browser  Funktionen werden durch Konfiguration (ohne Neukompilieren) hinzugef\u00fcgt", 
            "title": "Plugin"
        }, 
        {
            "location": "/apparch/component_dynamics_container_patterns/#inversion-of-control", 
            "text": "Frameworks steuern den Fluss selber, Komponenten werden  vom Framework aufgerufen  Problem: Wie wird definiert, wie Frameworks die Komponenten finden kann?  -  Dependency Injection", 
            "title": "Inversion of Control"
        }, 
        {
            "location": "/apparch/DDD_coding-style/", 
            "text": "Tactic DDD \n Architecturally Evident Coding Style\n\n\nRecap\n\n\n\n\nSpringDIAssember\n ist ein erfundener Name, steht f\u00fcr Dependency Injection Komponente von Spring\n\n\n\n\nDomain Model Pattern (PoEAA)\n\n\n\n\nBei Fowler nur sehr knapp definiert, mehr in DDD\n\n\n\n\nBusiness Layer Logic\n\n\n\n\nVerschiedene Arten von Business-Logik: Berechnungen, CRUD, Checks, Reporting, etc.\n\n\n\n\nTactic Domain Driven Design\n\n\n\n\n\"Zoom-in\" auf Domain-Model\n\n\nStrategie: Langfristig, Taktik: Kurzfristige Entscheidungen, um Ziele zu erreichen\n\n\nModifiziertes Layer-Modell\n\n\nInterfaces\n: quasi Presentation Layer\n\n\nApplication\n: Business Logik\n\n\nInfrastructure\n: Data Access, quer zu den anderen Schichten! Geh\u00f6rt eigentlich eher unter Domain\n\n\n\n\n\n\nUbiquitous Language: Sprache von DDD soll \"allgegenw\u00e4rtig\" und einheitlich in der Applikation sein\n\n\nBest Practice: An Aggregate-Grenzen nur Objekt-Ids \u00fcberbgeben, keine Referenzen (Entkopplung)\n\n\n\n\nDDD Patterns\n\n\n\n\nEinteilung von \nEntities\n, \nServices\n und \nvalue objects\n (siehe APF)\n\n\nKlassen mit lediglich \"Do-er\" Methoden (stateless) sind \nservices\n\n\n\n\n\n\nAggregate Pattern: Entities und Value Objects in \nAggregates\n gruppieren\n\n\nAnalog SE1/SE2: Partitionieren\n\n\nJedes Aggregate hat eine \nroot Entity\n, die Zugriff zu anderen Entities bietet und Business Rules (Invariants, Pre-- und Post-conditions) \u00fcberpr\u00fcft\n\n\nAggregate selbst ist keine Klasse, nur ein package!\n\n\n\n\n\n\nPro aggregate und root entity eine \nFactory\n implementieren\n\n\nEine \nRepository\n-Klasse pro Aggregate f\u00fcr alle Entities definieren, die abgerufen werden sollen (per id)\n\n\nz.B. \nfind()\n, \nstore()\n\n\n\n\n\n\n\n\nArchitecturally Evident Coding Styles (AECS)\n\n\n\n\nArchitektur soll im Code nicht \"verloren\" gehen\n\n\nStartup-Code soll zentralisiert sein (und klar benannt)\n\n\nIn DDD: \"Intention Revealing Interfaces\"\n\n\n2-3 W\u00f6rter pro Name\n\n\nStarke Verben verwenden (nicht \"set\", \"change\")", 
            "title": "Tactic DDD & Architectural Coding Style"
        }, 
        {
            "location": "/apparch/DDD_coding-style/#tactic-ddd-architecturally-evident-coding-style", 
            "text": "", 
            "title": "Tactic DDD &amp; Architecturally Evident Coding Style"
        }, 
        {
            "location": "/apparch/DDD_coding-style/#recap", 
            "text": "SpringDIAssember  ist ein erfundener Name, steht f\u00fcr Dependency Injection Komponente von Spring", 
            "title": "Recap"
        }, 
        {
            "location": "/apparch/DDD_coding-style/#domain-model-pattern-poeaa", 
            "text": "Bei Fowler nur sehr knapp definiert, mehr in DDD", 
            "title": "Domain Model Pattern (PoEAA)"
        }, 
        {
            "location": "/apparch/DDD_coding-style/#business-layer-logic", 
            "text": "Verschiedene Arten von Business-Logik: Berechnungen, CRUD, Checks, Reporting, etc.", 
            "title": "Business Layer Logic"
        }, 
        {
            "location": "/apparch/DDD_coding-style/#tactic-domain-driven-design", 
            "text": "\"Zoom-in\" auf Domain-Model  Strategie: Langfristig, Taktik: Kurzfristige Entscheidungen, um Ziele zu erreichen  Modifiziertes Layer-Modell  Interfaces : quasi Presentation Layer  Application : Business Logik  Infrastructure : Data Access, quer zu den anderen Schichten! Geh\u00f6rt eigentlich eher unter Domain    Ubiquitous Language: Sprache von DDD soll \"allgegenw\u00e4rtig\" und einheitlich in der Applikation sein  Best Practice: An Aggregate-Grenzen nur Objekt-Ids \u00fcberbgeben, keine Referenzen (Entkopplung)", 
            "title": "Tactic Domain Driven Design"
        }, 
        {
            "location": "/apparch/DDD_coding-style/#ddd-patterns", 
            "text": "Einteilung von  Entities ,  Services  und  value objects  (siehe APF)  Klassen mit lediglich \"Do-er\" Methoden (stateless) sind  services    Aggregate Pattern: Entities und Value Objects in  Aggregates  gruppieren  Analog SE1/SE2: Partitionieren  Jedes Aggregate hat eine  root Entity , die Zugriff zu anderen Entities bietet und Business Rules (Invariants, Pre-- und Post-conditions) \u00fcberpr\u00fcft  Aggregate selbst ist keine Klasse, nur ein package!    Pro aggregate und root entity eine  Factory  implementieren  Eine  Repository -Klasse pro Aggregate f\u00fcr alle Entities definieren, die abgerufen werden sollen (per id)  z.B.  find() ,  store()", 
            "title": "DDD Patterns"
        }, 
        {
            "location": "/apparch/DDD_coding-style/#architecturally-evident-coding-styles-aecs", 
            "text": "Architektur soll im Code nicht \"verloren\" gehen  Startup-Code soll zentralisiert sein (und klar benannt)  In DDD: \"Intention Revealing Interfaces\"  2-3 W\u00f6rter pro Name  Starke Verben verwenden (nicht \"set\", \"change\")", 
            "title": "Architecturally Evident Coding Styles (AECS)"
        }, 
        {
            "location": "/apparch/soa_restful/", 
            "text": "Service-Oriented Architectures / Restful HTTP\n\n\nApplication Styles\n\n\n\n\nZiel: Komponenten miteinander integrieren\n\n\n4+1-Viewpoint \nProcess\n\n\nIm Sinne von OS-Prozessen\n\n\n\n\n\n\nNach Fowler: Komponente ist lokal, Service ist eine Remote-Komponenten, der \u00fcber ein Interface angesprochen wird\n\n\n\n\nService Layer Pattern\n\n\n\n\nZwischen Domain- und UI-Layer einen Service-Layer einschieben, um komplexe Domain-Modelle vom Presentation-Layer zu verstecken\n\n\nVerantwortlichkeiten z.B. f\u00fcr Exception Handling, Access Control, Logging\n\n\n\n\nDTO Pattern\n\n\n\n\nDaten-Objekt ohne Businesslogik\n\n\nKann z.B. Methoden wie \ntoXML()\n haben\n\n\n\n\nSOA\n\n\n\n\n\"Begriff \u00fcberladen\"\n\n\nGrunds\u00e4tzlich ein Set von Services, das von einem Business angeboten wird\n\n\nAuch ein Set von Architektur-Patterns\n\n\nDeployment Models wie mit Docker, Container, etc.\n\n\n\n\nLoose Kopplung\n\n\n\n\nZeitliche Entkopplung: Client und Server m\u00fcssen nicht zur gleichen Zeit aktiv sein (ohne Datenverlust) - Message Queueing\n\n\nAdress-Transparenz/-Autonomie: \"Location-Transparency\"\n\n\nz.B. man gibt URI statt MAC-Adresse ein\n\n\n\n\n\n\nPlattform-Autonomie: Man weiss z.B. nicht, in welcher Sprache die andere Komponente (Client/Server) geschrieben ist\n\n\nGegenbeispiel: Java RMI\n\n\n\n\n\n\nFormat-Autonomie: Client und Server m\u00fcssen sich nicht auf ein Datenmodell einigen\n\n\nSiehe Pattern \"Enterprise Service Bus\", Anti-Corruption Layer\n\n\n\n\n\n\n\n\nREST\n\n\n\n\nRepresentational State Transfer\n\n\nREST ist ein Architekturstil, definiert \u00fcber Constraints (Einschr\u00e4nkungen)\n\n\nUrspr\u00fcnglich v\u00f6llig Stateless (Server merkt sich nicht, was er vom Client schon erhalten hat)\n\n\nD.h z.B. ohne Cookies\n\n\nDadurch sehr einfach verteilbar\n\n\n\"AS\" (Application State) in HATEOS\n\n\n\n\n\n\n\n\nREST Majurity Model\n\n\n\n\nZiel: Level 3 (HATEOS) -\n Restful HTTP\n\n\nNicht jedes HTTP-API erf\u00fcllt die REST-Kriterien!\n\n\nWichtigste Eigenschaft: Resources\n\n\nHaben jeweils genau eine URI\n\n\n\n\n\n\nHTTP-Verben: NUR HTTP-Verben auf Ressourcen aufrufen\n\n\nIst nicht mehr Platform-Neutral!\n\n\nHTTP ist einzige reale \"Implementation\" von REST\n\n\n\n\n\n\n\n\nHatEoAS\n\n\n\n\nHypertext as the Engine of Application State\n\n\nCustom Media Types\n\n\nz.B. \napplication/json\n\n\n\n\n\n\nMedia Types tragen den Application State (Engine)\n\n\nLinks identifizieren den Application State\n\n\nWas sind die n\u00e4chsten g\u00fcltigen Operationen?\n\n\n\n\n\n\nBringt viel Flexibilit\u00e4t, aber auch Unsicherheit\n\n\nKontrollfluss wird abgegeben an Endpoint\n\n\nDadurch oft nicht verwendet in Application Integration\n\n\n\n\n\n\n\n\n\n\nAsynchrone Calls\n\n\nz.B. eine Ressource \"Process\" machen, \u00fcber die der Status einer Operation (State) abgefragt werden kann", 
            "title": "SOA / RESTful HTTP"
        }, 
        {
            "location": "/apparch/soa_restful/#service-oriented-architectures-restful-http", 
            "text": "", 
            "title": "Service-Oriented Architectures / Restful HTTP"
        }, 
        {
            "location": "/apparch/soa_restful/#application-styles", 
            "text": "Ziel: Komponenten miteinander integrieren  4+1-Viewpoint  Process  Im Sinne von OS-Prozessen    Nach Fowler: Komponente ist lokal, Service ist eine Remote-Komponenten, der \u00fcber ein Interface angesprochen wird", 
            "title": "Application Styles"
        }, 
        {
            "location": "/apparch/soa_restful/#service-layer-pattern", 
            "text": "Zwischen Domain- und UI-Layer einen Service-Layer einschieben, um komplexe Domain-Modelle vom Presentation-Layer zu verstecken  Verantwortlichkeiten z.B. f\u00fcr Exception Handling, Access Control, Logging", 
            "title": "Service Layer Pattern"
        }, 
        {
            "location": "/apparch/soa_restful/#dto-pattern", 
            "text": "Daten-Objekt ohne Businesslogik  Kann z.B. Methoden wie  toXML()  haben", 
            "title": "DTO Pattern"
        }, 
        {
            "location": "/apparch/soa_restful/#soa", 
            "text": "\"Begriff \u00fcberladen\"  Grunds\u00e4tzlich ein Set von Services, das von einem Business angeboten wird  Auch ein Set von Architektur-Patterns  Deployment Models wie mit Docker, Container, etc.", 
            "title": "SOA"
        }, 
        {
            "location": "/apparch/soa_restful/#loose-kopplung", 
            "text": "Zeitliche Entkopplung: Client und Server m\u00fcssen nicht zur gleichen Zeit aktiv sein (ohne Datenverlust) - Message Queueing  Adress-Transparenz/-Autonomie: \"Location-Transparency\"  z.B. man gibt URI statt MAC-Adresse ein    Plattform-Autonomie: Man weiss z.B. nicht, in welcher Sprache die andere Komponente (Client/Server) geschrieben ist  Gegenbeispiel: Java RMI    Format-Autonomie: Client und Server m\u00fcssen sich nicht auf ein Datenmodell einigen  Siehe Pattern \"Enterprise Service Bus\", Anti-Corruption Layer", 
            "title": "Loose Kopplung"
        }, 
        {
            "location": "/apparch/soa_restful/#rest", 
            "text": "Representational State Transfer  REST ist ein Architekturstil, definiert \u00fcber Constraints (Einschr\u00e4nkungen)  Urspr\u00fcnglich v\u00f6llig Stateless (Server merkt sich nicht, was er vom Client schon erhalten hat)  D.h z.B. ohne Cookies  Dadurch sehr einfach verteilbar  \"AS\" (Application State) in HATEOS", 
            "title": "REST"
        }, 
        {
            "location": "/apparch/soa_restful/#rest-majurity-model", 
            "text": "Ziel: Level 3 (HATEOS) -  Restful HTTP  Nicht jedes HTTP-API erf\u00fcllt die REST-Kriterien!  Wichtigste Eigenschaft: Resources  Haben jeweils genau eine URI    HTTP-Verben: NUR HTTP-Verben auf Ressourcen aufrufen  Ist nicht mehr Platform-Neutral!  HTTP ist einzige reale \"Implementation\" von REST", 
            "title": "REST Majurity Model"
        }, 
        {
            "location": "/apparch/soa_restful/#hateoas", 
            "text": "Hypertext as the Engine of Application State  Custom Media Types  z.B.  application/json    Media Types tragen den Application State (Engine)  Links identifizieren den Application State  Was sind die n\u00e4chsten g\u00fcltigen Operationen?    Bringt viel Flexibilit\u00e4t, aber auch Unsicherheit  Kontrollfluss wird abgegeben an Endpoint  Dadurch oft nicht verwendet in Application Integration      Asynchrone Calls  z.B. eine Ressource \"Process\" machen, \u00fcber die der Status einer Operation (State) abgefragt werden kann", 
            "title": "HatEoAS"
        }, 
        {
            "location": "/apparch/esb/", 
            "text": "Enterprise Service Bus (Guest Lecture)\n\n\nMotivation\n\n\n\n\nViele Services (ERP, CRM, etc.)\n\n\nIntegration, um zwischen den Services kommunizieren zu k\u00f6nnen\n\n\nVerschiedene Protokolle / Datenformate der Systeme\n\n\nPunkt-zu-Punkt-Verbindungen erzeugen starke Kopplung der Systeme\n\n\n\n\nDefinitionen\n\n\n\n\n\"An enterprise service bus (ESB) is a software architecture model used for designing and implementing the interaction and communication between interacting software applications in service-oriented architecture (SOA).\u201c\n\n\nArchitektur-Pattern und Produktkategorie\n\n\nImplementation von Anti Corruption Layer (ACL)\n\n\n\n\nL\u00f6sung\n\n\n\n\nF\u00fcr jede Technologie einen Adapter\n\n\nVerarbeitungsflow wird innerhalb ESB definiert\n\n\nWenn Technologie an einer Schnittstelle \u00e4ndert, muss nur der Adapter ausgetauscht werden\n\n\nWenn ein kanonisches Datenmodell existiert (f\u00fcr die ganze Firma), muss lediglich jedes andere Datenmodell darin \u00fcbersetzt werden. Sonst muss f\u00fcr jede Verbindung zwischen zwei Protokolle \u00fcbersetzt werden\n\n\n\n\nVersionierung\n\n\n\n\nESB kann Funktionalit\u00e4t zur Verf\u00fcgung stellen, um zwischen verschiedenen Versionen zu \u00fcbersetzen\n\n\n\n\nXQuery\n\n\n\n\nMapping zwischen zwei Datenformaten\n\n\nCode oder \u00fcber grafische Tools", 
            "title": "Enterprise Service Bus"
        }, 
        {
            "location": "/apparch/esb/#enterprise-service-bus-guest-lecture", 
            "text": "", 
            "title": "Enterprise Service Bus (Guest Lecture)"
        }, 
        {
            "location": "/apparch/esb/#motivation", 
            "text": "Viele Services (ERP, CRM, etc.)  Integration, um zwischen den Services kommunizieren zu k\u00f6nnen  Verschiedene Protokolle / Datenformate der Systeme  Punkt-zu-Punkt-Verbindungen erzeugen starke Kopplung der Systeme", 
            "title": "Motivation"
        }, 
        {
            "location": "/apparch/esb/#definitionen", 
            "text": "\"An enterprise service bus (ESB) is a software architecture model used for designing and implementing the interaction and communication between interacting software applications in service-oriented architecture (SOA).\u201c  Architektur-Pattern und Produktkategorie  Implementation von Anti Corruption Layer (ACL)", 
            "title": "Definitionen"
        }, 
        {
            "location": "/apparch/esb/#losung", 
            "text": "F\u00fcr jede Technologie einen Adapter  Verarbeitungsflow wird innerhalb ESB definiert  Wenn Technologie an einer Schnittstelle \u00e4ndert, muss nur der Adapter ausgetauscht werden  Wenn ein kanonisches Datenmodell existiert (f\u00fcr die ganze Firma), muss lediglich jedes andere Datenmodell darin \u00fcbersetzt werden. Sonst muss f\u00fcr jede Verbindung zwischen zwei Protokolle \u00fcbersetzt werden", 
            "title": "L\u00f6sung"
        }, 
        {
            "location": "/apparch/esb/#versionierung", 
            "text": "ESB kann Funktionalit\u00e4t zur Verf\u00fcgung stellen, um zwischen verschiedenen Versionen zu \u00fcbersetzen", 
            "title": "Versionierung"
        }, 
        {
            "location": "/apparch/esb/#xquery", 
            "text": "Mapping zwischen zwei Datenformaten  Code oder \u00fcber grafische Tools", 
            "title": "XQuery"
        }, 
        {
            "location": "/apparch/microservices/", 
            "text": "Service Contracts \n Microservices\n\n\nEinschub SOAP\n\n\n\n\nUrspr\u00fcnglich Simple Object Access Protocol, aber jetzt nur noch als Eigenname definiert\n\n\nXML-Format, was den \"Wunsch\" des Service Requestors an den Provider beschreibt\n\n\nIn jedem Body Entry ist ein Schema definiert, das den \"Contract\" bildet\n\n\nUnterscheiden von RPC! Ist konzeptionell nur ein \"Intent\" etwas zu machen, nicht direkt ein Call\n\n\nAlles geht \u00fcber POST (Kritik von REST-Leuten)\n\n\n\n\nWSDL\n\n\n\n\nXML-Schema f\u00fcr Service Contracts\n\n\nDefiniert auch Datenschema, was in REST lange nicht gemacht wurde\n\n\nREST kann auch mit WSDL 2.0 beschrieben werden, hat sich aber nicht durgesetzt gegen RESTful HTTP\n\n\n\n\nMicroservices\n\n\n\n\nVorher \"fine-grained SOA\"\n\n\nJede Komponente ist ein Service, der separat deployed werden kann (aber nicht muss)\n\n\nJeder Service kann unterschiedlichen Storage / Programmiersprache verwenden\n\n\nSo kann separat skaliert werden, z.B. nur den Katalog eines Online-Shops rauf skalieren bei Black Friday\n\n\nNach Fowler ein eigener Architektur-Stil (O. Zimmermann disagrees)\n\n\nAus DDD: Jedes Aggregate kann ein Microservice sein\n\n\n\n\nResources\n\n\n\n\nhttps://www.subbu.org/blog/2008/09/on-linking-part-2", 
            "title": "Service Contract & Microservices"
        }, 
        {
            "location": "/apparch/microservices/#service-contracts-microservices", 
            "text": "", 
            "title": "Service Contracts &amp; Microservices"
        }, 
        {
            "location": "/apparch/microservices/#einschub-soap", 
            "text": "Urspr\u00fcnglich Simple Object Access Protocol, aber jetzt nur noch als Eigenname definiert  XML-Format, was den \"Wunsch\" des Service Requestors an den Provider beschreibt  In jedem Body Entry ist ein Schema definiert, das den \"Contract\" bildet  Unterscheiden von RPC! Ist konzeptionell nur ein \"Intent\" etwas zu machen, nicht direkt ein Call  Alles geht \u00fcber POST (Kritik von REST-Leuten)", 
            "title": "Einschub SOAP"
        }, 
        {
            "location": "/apparch/microservices/#wsdl", 
            "text": "XML-Schema f\u00fcr Service Contracts  Definiert auch Datenschema, was in REST lange nicht gemacht wurde  REST kann auch mit WSDL 2.0 beschrieben werden, hat sich aber nicht durgesetzt gegen RESTful HTTP", 
            "title": "WSDL"
        }, 
        {
            "location": "/apparch/microservices/#microservices", 
            "text": "Vorher \"fine-grained SOA\"  Jede Komponente ist ein Service, der separat deployed werden kann (aber nicht muss)  Jeder Service kann unterschiedlichen Storage / Programmiersprache verwenden  So kann separat skaliert werden, z.B. nur den Katalog eines Online-Shops rauf skalieren bei Black Friday  Nach Fowler ein eigener Architektur-Stil (O. Zimmermann disagrees)  Aus DDD: Jedes Aggregate kann ein Microservice sein", 
            "title": "Microservices"
        }, 
        {
            "location": "/apparch/microservices/#resources", 
            "text": "https://www.subbu.org/blog/2008/09/on-linking-part-2", 
            "title": "Resources"
        }, 
        {
            "location": "/apparch/state_event_mgmt/", 
            "text": "State and Event Management / Service Granularity\n\n\n\n\nProblem bei Microservices: Ein Service kann nur auf eigenen Daten operieren. Was, wenn globale Transaktion ausgef\u00fchrt werden muss?\n\n\n\n\nStatelessness\n\n\n\n\nSession state\n und \nresource state\n sind Unterbegriffe von \napplication state\n\n\nsession state\n ist auf dem Presentation layer, nicht interessant f\u00fcr domain layer, z.B. Page flow auf website\n\n\nresource state\n ist auf Business Ebene, die Resources sind REST-Ressourcen, z.B. Entities\n\n\nREST erlaubt streng genommen gar keine Cookies\n\n\nServer Session State ist unpopul\u00e4r wegen schlechter Skalierbarkeit, besser gleich Session in Datenbank speichern (z.B. Redis)\n\n\nSo ist Session nat\u00fcrlich auch einfacher zu archivieren und auszuwerten. Bei REST ist das viel schwieriger (m\u00f6glicher Grund f\u00fcr Verbreitung)\n\n\n\n\n\n\n\n\nEvent Sourcing\n\n\n\n\nBei leerem application state anfangen und change logs verwenden (\u00e4hnlich Git)\n\n\nAlle \u00c4nderungen gehen \u00fcber Events\n\n\nEs werden Checkpoints gesetzt in der \"Kette\" der Events\n\n\nErlaubt komplette Audit Logs, oder z.B. Messaging zwischen Aggregates in DDD\n\n\nCoupling:\n\n\nEvents sind time- und reference-decoupled\n\n\nPlatform-decoupling mit XML / JSON\n\n\nFormat-coupling: Empf\u00e4nger und Sender m\u00fcssen sich auf Datenformat einigen\n\n\n\n\n\n\n\n\nCommand Query Responsibility Segregation (CQRS)\n\n\n\n\nDomain Model auseinander ziehen\n\n\nEines ist auf Reads und eines auf Writes optimiert\n\n\nN\u00fctzlich, wenn grosse Imbalance zwischen Read und Write \n\n\nRead-Cache f\u00fcr schnelles Lesen\n\n\nSchreib-Operationen werden eventually consistent in den Read Storage \u00fcbertragen\n\n\nGut, wenn Performance wichtiger als Korrektheit ist\n\n\nSchwierig, konsistent zu halten\n\n\n\n\nService Granularity\n\n\n\n\nMaster Data Separation: Lang-lebende Objekte werden abgekapselt\n\n\nLoose Kopplung zwischen gr\u00f6sseren Services ist einfacher als zwischen vielen kleinen Services\n\n\nBusiness Granularit\u00e4t: \"Gib den Status der Bestellung\" (fein granular)\n\n\nTechnische Granularit\u00e4t: Beeinflusst Performance und Skalierbarkeit, z.B. Anzahl Operationen im System\n\n\nBsp: \"Tweets der letzten 30 Minuten\" ist auf Business-Ebene feingranular, auf technischer Ebene sind das aber viele Daten, also grob granular", 
            "title": "State and Event Management / Service Granularity"
        }, 
        {
            "location": "/apparch/state_event_mgmt/#state-and-event-management-service-granularity", 
            "text": "Problem bei Microservices: Ein Service kann nur auf eigenen Daten operieren. Was, wenn globale Transaktion ausgef\u00fchrt werden muss?", 
            "title": "State and Event Management / Service Granularity"
        }, 
        {
            "location": "/apparch/state_event_mgmt/#statelessness", 
            "text": "Session state  und  resource state  sind Unterbegriffe von  application state  session state  ist auf dem Presentation layer, nicht interessant f\u00fcr domain layer, z.B. Page flow auf website  resource state  ist auf Business Ebene, die Resources sind REST-Ressourcen, z.B. Entities  REST erlaubt streng genommen gar keine Cookies  Server Session State ist unpopul\u00e4r wegen schlechter Skalierbarkeit, besser gleich Session in Datenbank speichern (z.B. Redis)  So ist Session nat\u00fcrlich auch einfacher zu archivieren und auszuwerten. Bei REST ist das viel schwieriger (m\u00f6glicher Grund f\u00fcr Verbreitung)", 
            "title": "Statelessness"
        }, 
        {
            "location": "/apparch/state_event_mgmt/#event-sourcing", 
            "text": "Bei leerem application state anfangen und change logs verwenden (\u00e4hnlich Git)  Alle \u00c4nderungen gehen \u00fcber Events  Es werden Checkpoints gesetzt in der \"Kette\" der Events  Erlaubt komplette Audit Logs, oder z.B. Messaging zwischen Aggregates in DDD  Coupling:  Events sind time- und reference-decoupled  Platform-decoupling mit XML / JSON  Format-coupling: Empf\u00e4nger und Sender m\u00fcssen sich auf Datenformat einigen", 
            "title": "Event Sourcing"
        }, 
        {
            "location": "/apparch/state_event_mgmt/#command-query-responsibility-segregation-cqrs", 
            "text": "Domain Model auseinander ziehen  Eines ist auf Reads und eines auf Writes optimiert  N\u00fctzlich, wenn grosse Imbalance zwischen Read und Write   Read-Cache f\u00fcr schnelles Lesen  Schreib-Operationen werden eventually consistent in den Read Storage \u00fcbertragen  Gut, wenn Performance wichtiger als Korrektheit ist  Schwierig, konsistent zu halten", 
            "title": "Command Query Responsibility Segregation (CQRS)"
        }, 
        {
            "location": "/apparch/state_event_mgmt/#service-granularity", 
            "text": "Master Data Separation: Lang-lebende Objekte werden abgekapselt  Loose Kopplung zwischen gr\u00f6sseren Services ist einfacher als zwischen vielen kleinen Services  Business Granularit\u00e4t: \"Gib den Status der Bestellung\" (fein granular)  Technische Granularit\u00e4t: Beeinflusst Performance und Skalierbarkeit, z.B. Anzahl Operationen im System  Bsp: \"Tweets der letzten 30 Minuten\" ist auf Business-Ebene feingranular, auf technischer Ebene sind das aber viele Daten, also grob granular", 
            "title": "Service Granularity"
        }, 
        {
            "location": "/apparch/cs-architecture/", 
            "text": "Guest Lecture Credit Suisse\n\n\nPlanning IT Infrastructure\n\n\n\n\nWhat is the current state?\n\n\nflows, pain point, etc.\n\n\n\n\n\n\nDefine Strategy\n\n\ntarget state, roadmap, agile\n\n\n\n\n\n\nGovernance\n\n\ncontrol and execution", 
            "title": "Guest Lecture Credit Suisse"
        }, 
        {
            "location": "/apparch/cs-architecture/#guest-lecture-credit-suisse", 
            "text": "", 
            "title": "Guest Lecture Credit Suisse"
        }, 
        {
            "location": "/apparch/cs-architecture/#planning-it-infrastructure", 
            "text": "What is the current state?  flows, pain point, etc.    Define Strategy  target state, roadmap, agile    Governance  control and execution", 
            "title": "Planning IT Infrastructure"
        }, 
        {
            "location": "/apparch/evaluation_summary/", 
            "text": "Evaluation \n Lecture Closure\n\n\nArchitectural Evaluation\n\n\n\n\n\"Burger\"-Technik: Positiv anfangen, Negatives in der Mitte, Positives am Ende\n\n\nFindings, die nicht umgesetzt werden k\u00f6nnen, sollten mit der Zeit verbessert werden k\u00f6nnen\n\n\n\n\nRepetition\n\n\n\n\nSW-Architektur vs. Application Architecture\n\n\nViewpoints\n\n\nNFR sollen SMART sein\n\n\nQuality Attribute Scenario (QAS) - was geh\u00f6rt wohin? -\n Template\n\n\nCRC Cards: Stichworte oder Kurzs\u00e4tze\n\n\nBounded Context vs. Subdomain: Reality vs. Wishful thinking\n\n\nLayers\n\n\nBPMN kann u.U. auf Architektur-Schichten \u00fcbertragen werden (z.B. mit \nKamunda\n)\n\n\n\n\nPr\u00fcfung\n\n\n\n\nFolien, \u00dcbungen, Factsheets, Wiederholungsfragen\n\n\nProbepr\u00fcfungen, \u00dcbung 14 mit Beispielfragen (und FAQ zur Pr\u00fcfung)\n\n\nSelf-study assignment 5 mit Bullet-list zu Pr\u00fcfungsthemen\n\n\nAusblick dieser Vorlesung nicht pr\u00fcfungsrelevant", 
            "title": "Evaluation / Summary"
        }, 
        {
            "location": "/apparch/evaluation_summary/#evaluation-lecture-closure", 
            "text": "", 
            "title": "Evaluation &amp; Lecture Closure"
        }, 
        {
            "location": "/apparch/evaluation_summary/#architectural-evaluation", 
            "text": "\"Burger\"-Technik: Positiv anfangen, Negatives in der Mitte, Positives am Ende  Findings, die nicht umgesetzt werden k\u00f6nnen, sollten mit der Zeit verbessert werden k\u00f6nnen", 
            "title": "Architectural Evaluation"
        }, 
        {
            "location": "/apparch/evaluation_summary/#repetition", 
            "text": "SW-Architektur vs. Application Architecture  Viewpoints  NFR sollen SMART sein  Quality Attribute Scenario (QAS) - was geh\u00f6rt wohin? -  Template  CRC Cards: Stichworte oder Kurzs\u00e4tze  Bounded Context vs. Subdomain: Reality vs. Wishful thinking  Layers  BPMN kann u.U. auf Architektur-Schichten \u00fcbertragen werden (z.B. mit  Kamunda )", 
            "title": "Repetition"
        }, 
        {
            "location": "/apparch/evaluation_summary/#prufung", 
            "text": "Folien, \u00dcbungen, Factsheets, Wiederholungsfragen  Probepr\u00fcfungen, \u00dcbung 14 mit Beispielfragen (und FAQ zur Pr\u00fcfung)  Self-study assignment 5 mit Bullet-list zu Pr\u00fcfungsthemen  Ausblick dieser Vorlesung nicht pr\u00fcfungsrelevant", 
            "title": "Pr\u00fcfung"
        }, 
        {
            "location": "/apparch/exercises/ex1/", 
            "text": "Exercise 1\n\n\n\n\n\n\n\n\nRequirement\n\n\nScore\n\n\nMapping\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nCache V2 Kubernetes provider resources (#1919)\n\n\n\n\n\n\n\n\n\n\n\n\nReplace all Frigga usage in Orca (#1920)\n\n\nL-M\n\n\n\n\nFrigga ist eine alte Library, die String Parsing macht; wohl nicht wichtig f\u00fcr QoS\n\n\n\n\n\n\nSupport for custom basePath of Swagger\n\n\nL\n\n\n\n\nSwagger ist API-Framework; Wohl nicht wichtig f\u00fcr Architektur", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/apparch/exercises/ex1/#exercise-1", 
            "text": "Requirement  Score  Mapping  Explanation      Cache V2 Kubernetes provider resources (#1919)       Replace all Frigga usage in Orca (#1920)  L-M   Frigga ist eine alte Library, die String Parsing macht; wohl nicht wichtig f\u00fcr QoS    Support for custom basePath of Swagger  L   Swagger ist API-Framework; Wohl nicht wichtig f\u00fcr Architektur", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/apf/", 
            "text": "Advanced Patterns and Frameworks", 
            "title": "Index"
        }, 
        {
            "location": "/apf/#advanced-patterns-and-frameworks", 
            "text": "", 
            "title": "Advanced Patterns and Frameworks"
        }, 
        {
            "location": "/apf/intro/", 
            "text": "APF Intro\n\n\nWas sind Patterns\n\n\n\n\nUrpsrung: Architektur Patterns von Christopher Alexander\n\n\nGenerische L\u00f6sungen f\u00fcr h\u00e4ufige Engineering-Probleme\n\n\nPattern ist selten 1:1 implementierbar\n\n\nForces: Was sind die Probleme und Rahmenbedingungen, die mit einem Pattern gel\u00f6st werden k\u00f6nnen?\n\n\nConsequences: Gut und schlechte Resultate des Patterns\n\n\nPattern Language: Patterns werden miteinander verkn\u00fcpft und bauen aufeinander auf\n\n\nGenerelle Prinzipen sind \nkeine\n Patterns! (DRY, SOLID, etc.)\n\n\nSOLID: \n\n\nSingle Responsibility\n\n\nOpen-Closed: offen f\u00fcr Erweiterung, keine Ver\u00e4nderung von Clients notwendig)\n\n\nLizkov-Substitution Principle\n\n\nInterface segregation principle: Interfaces abspalten\n\n\nDependency Inversion: Abh\u00e4ngigkeiten immer vom konkreten zum abstrakten\n\n\n\n\n\n\n\n\n\n\n\n\nRelevante Patterns\n\n\n\n\nGoF-Patterns (ohne Singleton)\n\n\nEinteilung in drei Teile ist eher k\u00fcnstlich\n\n\n\n\n\n\nPOSA 1: Pattern h\u00e4ngen miteinander zusammen", 
            "title": "Introduction"
        }, 
        {
            "location": "/apf/intro/#apf-intro", 
            "text": "", 
            "title": "APF Intro"
        }, 
        {
            "location": "/apf/intro/#was-sind-patterns", 
            "text": "Urpsrung: Architektur Patterns von Christopher Alexander  Generische L\u00f6sungen f\u00fcr h\u00e4ufige Engineering-Probleme  Pattern ist selten 1:1 implementierbar  Forces: Was sind die Probleme und Rahmenbedingungen, die mit einem Pattern gel\u00f6st werden k\u00f6nnen?  Consequences: Gut und schlechte Resultate des Patterns  Pattern Language: Patterns werden miteinander verkn\u00fcpft und bauen aufeinander auf  Generelle Prinzipen sind  keine  Patterns! (DRY, SOLID, etc.)  SOLID:   Single Responsibility  Open-Closed: offen f\u00fcr Erweiterung, keine Ver\u00e4nderung von Clients notwendig)  Lizkov-Substitution Principle  Interface segregation principle: Interfaces abspalten  Dependency Inversion: Abh\u00e4ngigkeiten immer vom konkreten zum abstrakten", 
            "title": "Was sind Patterns"
        }, 
        {
            "location": "/apf/intro/#relevante-patterns", 
            "text": "GoF-Patterns (ohne Singleton)  Einteilung in drei Teile ist eher k\u00fcnstlich    POSA 1: Pattern h\u00e4ngen miteinander zusammen", 
            "title": "Relevante Patterns"
        }, 
        {
            "location": "/apf/gof_revisited/", 
            "text": "GoF Revisited\n\n\nRepetition\n\n\nObserver\n\n\nDefine a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\n\n\nStrategy\n\n\nDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n\n\nTemplate Method\n\n\nDefine the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.\n\n\nAbstract Factory\n\n\nProvide an interface for creating families of related or dependent objects without specifying their concrete classes.\n\n\nPrototype\n\n\nEine konkrete Instanz wird gecloned (statt mit Factory) f\u00fcr eine neue Instanz. So k\u00f6nnen gleiche Instanzen schnell erstellt werden, ohne sie jedes Mal neu zu instanzieren\n\n\nComposite\n\n\nCompose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.\n\n\n\n\nTransparent Composite: Oberklasse (Graphic) hat \nadd(Graphic)\n methode\n\n\nProblem: abgeleitete Klassen haben diese dann auch, k\u00f6nnen sie aber nicht brauchen!\n\n\n\n\n\n\n\n\nDecorator\n\n\nAttach additional responsibilities to an object dynamically. Decorators provide a flexible alternative\nto subclassing for extending functionality.\n\n\n\n\nAndere Intention als Composite: Man m\u00f6chte weitere Funktionalit\u00e4t einf\u00fchren, nicht einen Baum aufbauen. Es ist eine \"Kette\" von Funktionalit\u00e4t\n\n\n\n\nFacade\n\n\nProvide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use\n\n\nLesser Known Patterns\n\n\nMediator\n\n\n\n\nKommunikation unter Objekten sicherstellen, ohne dass die Objekte selbst Referenzen untereinander haben\n\n\nMediator ist oft Observer, die beteiligten Objekte Observables\n\n\nz.B. in \nupdate()\n die Updates von einem Colleague einem anderen Colleague \u00fcbergeben\n\n\n\n\n\n\nGut testbar, wenn sauber: Colleagues-Mocks dem Mediator \u00fcbergeben\n\n\nNachteil: Mediator ist SPOF,  kann sehr gross und unstrukturiert werden\n\n\n\n\nMemento\n\n\n\n\nEin Zustand eines Objektes auslagern, damit er sp\u00e4ter wiederhergestellt werden kann, ohne die Kapselung zu verletzen\n\n\nz.B. Savegames\n\n\nDer Zustand vom Originator wird in das Memento kopiert\n\n\nBeim Widerherstellen schreibt der Originator der Zustand vom Memento zu sich selber\n\n\nVorteil: Originator muss nicht seine Internals heraus geben\n\n\nNachteile:\n\n\nBraucht jedes Mal eine vollst\u00e4ndige Kopie\n\n\nViel Speicherplatz ben\u00f6tigt\n\n\n\n\n\n\n\n\nCommand\n\n\n\n\nEin Command kann herumgereicht werden (\"was gibt es auszuf\u00fchren\")\n\n\nCommand wird von einem Invoker ausgef\u00fchrt (\nexecute()\n)\n\n\nCommand kann z.B. geloggt oder scheduled (verz\u00f6gert) werden\n\n\nNachteil: Viele kleine Command-Klassen bei grossem Design, wird zersaust\n\n\nQuasi ein Function pointer, der herum gereicht wird\n\n\n\n\nCommand Processor\n\n\n\n\nWie Command, aber mit Undo / Redo\n\n\nz.B. Commands in Stack speichern als History\n\n\nDer Processor verwaltet die History\n\n\nCommand Processor gibt auch vor, wer die Commands ausf\u00fchrt, d\u00fcrfen nicht mehr \"beliebig\" herum geschoben werden!\n\n\n\n\nVisitor\n\n\n\n\nProblem: Klassenhierarchie braucht neue Methode, ohne die Klasse zu ver\u00e4ndern\n\n\nBeispiel Filesystem Serialisierung: Oberklasse \nFSObj\n hat Methode \naccept(visitor)\n. Die Unterklassen \"konsumieren\" den Visitor\n\n\nDer Visitor ist entweder ein \nXmlVisitor\n oder \nJSONVisitor\n\n\nUnterklassen rufen im \naccept()\n visitor mit Referenz auf sich selbst auf (z.B. in File: \nvisitor.visitFile(this)\n)\n\n\n\n\n\n\nNachteile: \n\n\nDie beiden Hierarchien sind gekoppelt, f\u00fcr neue Elemente m\u00fcssen beide Hierarchien angepasst werden beide Hierarchien angepasst werden\n\n\nGefahr von Code duplication, weil die Logik aufgebrochen wird\n\n\n\n\n\n\n\n\nFlyweight\n\n\n\n\nAusgangslange: Viele Objekte, die alle \"gleich\" sind, aber in einer Art (z.B. Position) unterschiedlich sind\n\n\nInterner State ist immer gleich, externer State kann sich \u00e4ndern\n\n\nZiel: Memory-sparend abbilden\n\n\nDie \nFlyweight\n-Klasse ist z.B. ein Baum\n\n\nFlyweightManager\nverwaltet die Objekte\n\n\nVom Flyweight gibt es nur eine Instanz, gehalten vom Manager \n\n\n\n\n\n\nDer interne (intrinsic) State ist f\u00fcr alle Objekte gleich (immutable Flyweights)\n\n\nDer externe State wird vom Client direkt dem konkreten Flyweight gegeben (und wird dort nicht gespeichert!)", 
            "title": "GoF Revisited"
        }, 
        {
            "location": "/apf/gof_revisited/#gof-revisited", 
            "text": "", 
            "title": "GoF Revisited"
        }, 
        {
            "location": "/apf/gof_revisited/#repetition", 
            "text": "", 
            "title": "Repetition"
        }, 
        {
            "location": "/apf/gof_revisited/#observer", 
            "text": "Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.", 
            "title": "Observer"
        }, 
        {
            "location": "/apf/gof_revisited/#strategy", 
            "text": "Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.", 
            "title": "Strategy"
        }, 
        {
            "location": "/apf/gof_revisited/#template-method", 
            "text": "Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.", 
            "title": "Template Method"
        }, 
        {
            "location": "/apf/gof_revisited/#abstract-factory", 
            "text": "Provide an interface for creating families of related or dependent objects without specifying their concrete classes.", 
            "title": "Abstract Factory"
        }, 
        {
            "location": "/apf/gof_revisited/#prototype", 
            "text": "Eine konkrete Instanz wird gecloned (statt mit Factory) f\u00fcr eine neue Instanz. So k\u00f6nnen gleiche Instanzen schnell erstellt werden, ohne sie jedes Mal neu zu instanzieren", 
            "title": "Prototype"
        }, 
        {
            "location": "/apf/gof_revisited/#composite", 
            "text": "Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.   Transparent Composite: Oberklasse (Graphic) hat  add(Graphic)  methode  Problem: abgeleitete Klassen haben diese dann auch, k\u00f6nnen sie aber nicht brauchen!", 
            "title": "Composite"
        }, 
        {
            "location": "/apf/gof_revisited/#decorator", 
            "text": "Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative\nto subclassing for extending functionality.   Andere Intention als Composite: Man m\u00f6chte weitere Funktionalit\u00e4t einf\u00fchren, nicht einen Baum aufbauen. Es ist eine \"Kette\" von Funktionalit\u00e4t", 
            "title": "Decorator"
        }, 
        {
            "location": "/apf/gof_revisited/#facade", 
            "text": "Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use", 
            "title": "Facade"
        }, 
        {
            "location": "/apf/gof_revisited/#lesser-known-patterns", 
            "text": "", 
            "title": "Lesser Known Patterns"
        }, 
        {
            "location": "/apf/gof_revisited/#mediator", 
            "text": "Kommunikation unter Objekten sicherstellen, ohne dass die Objekte selbst Referenzen untereinander haben  Mediator ist oft Observer, die beteiligten Objekte Observables  z.B. in  update()  die Updates von einem Colleague einem anderen Colleague \u00fcbergeben    Gut testbar, wenn sauber: Colleagues-Mocks dem Mediator \u00fcbergeben  Nachteil: Mediator ist SPOF,  kann sehr gross und unstrukturiert werden", 
            "title": "Mediator"
        }, 
        {
            "location": "/apf/gof_revisited/#memento", 
            "text": "Ein Zustand eines Objektes auslagern, damit er sp\u00e4ter wiederhergestellt werden kann, ohne die Kapselung zu verletzen  z.B. Savegames  Der Zustand vom Originator wird in das Memento kopiert  Beim Widerherstellen schreibt der Originator der Zustand vom Memento zu sich selber  Vorteil: Originator muss nicht seine Internals heraus geben  Nachteile:  Braucht jedes Mal eine vollst\u00e4ndige Kopie  Viel Speicherplatz ben\u00f6tigt", 
            "title": "Memento"
        }, 
        {
            "location": "/apf/gof_revisited/#command", 
            "text": "Ein Command kann herumgereicht werden (\"was gibt es auszuf\u00fchren\")  Command wird von einem Invoker ausgef\u00fchrt ( execute() )  Command kann z.B. geloggt oder scheduled (verz\u00f6gert) werden  Nachteil: Viele kleine Command-Klassen bei grossem Design, wird zersaust  Quasi ein Function pointer, der herum gereicht wird", 
            "title": "Command"
        }, 
        {
            "location": "/apf/gof_revisited/#command-processor", 
            "text": "Wie Command, aber mit Undo / Redo  z.B. Commands in Stack speichern als History  Der Processor verwaltet die History  Command Processor gibt auch vor, wer die Commands ausf\u00fchrt, d\u00fcrfen nicht mehr \"beliebig\" herum geschoben werden!", 
            "title": "Command Processor"
        }, 
        {
            "location": "/apf/gof_revisited/#visitor", 
            "text": "Problem: Klassenhierarchie braucht neue Methode, ohne die Klasse zu ver\u00e4ndern  Beispiel Filesystem Serialisierung: Oberklasse  FSObj  hat Methode  accept(visitor) . Die Unterklassen \"konsumieren\" den Visitor  Der Visitor ist entweder ein  XmlVisitor  oder  JSONVisitor  Unterklassen rufen im  accept()  visitor mit Referenz auf sich selbst auf (z.B. in File:  visitor.visitFile(this) )    Nachteile:   Die beiden Hierarchien sind gekoppelt, f\u00fcr neue Elemente m\u00fcssen beide Hierarchien angepasst werden beide Hierarchien angepasst werden  Gefahr von Code duplication, weil die Logik aufgebrochen wird", 
            "title": "Visitor"
        }, 
        {
            "location": "/apf/gof_revisited/#flyweight", 
            "text": "Ausgangslange: Viele Objekte, die alle \"gleich\" sind, aber in einer Art (z.B. Position) unterschiedlich sind  Interner State ist immer gleich, externer State kann sich \u00e4ndern  Ziel: Memory-sparend abbilden  Die  Flyweight -Klasse ist z.B. ein Baum  FlyweightManager verwaltet die Objekte  Vom Flyweight gibt es nur eine Instanz, gehalten vom Manager     Der interne (intrinsic) State ist f\u00fcr alle Objekte gleich (immutable Flyweights)  Der externe State wird vom Client direkt dem konkreten Flyweight gegeben (und wird dort nicht gespeichert!)", 
            "title": "Flyweight"
        }, 
        {
            "location": "/apf/beyond_gof/", 
            "text": "Beyond GoF\n\n\nEnumerator\n\n\n\n\nProbleme mit Iterator\n\n\nCollections d\u00fcrfen nie w\u00e4hrend Iteration ver\u00e4ndert werden\n\n\nUmgehung davon aufw\u00e4ndig, gibt enges coupling zwischen Iterator und Collection\n\n\n\n\n\n\nGoF hat externer Iterator (\"klassisch\") und interner Iterator (= Enumerator) vermischt\n\n\nEnumerator ist Inversion des Iterators\n\n\nCollection hat selbst eine Methode, die ein Kommando entgegen nimmt\n\n\nz.B. \nc.forEach(i =\n foo(i))\n\n\n\n\n\n\nIteration ist direkt in der Collection, dadurch hat es mehr Kontrolle, z.B. bei \u00c4nderungen w\u00e4hrend der Iteratation, oder mit Locking\n\n\nOhne Lambdas das Command-Pattern verwenden\n\n\n\n\nDistribution\n\n\n\n\nProblem bei Remote Calls, wenn f\u00fcr jedes Element ein eigener Call auf das Remote-system gemacht werden muss\n\n\nL\u00f6sung: \nBatch Method\n Pattern\n\n\nMehrere Elemente auf einmal schicken\n\n\n\n\n\n\n\n\nState Pattern\n\n\n\n\nGoF-Beschreibung ist sehr allgemein, besserer Name w\u00e4re \"Objects for States\"\n\n\nH\u00e4ufig overkill, oft ist auch ein primitives \"Flag-based\" State Management ausreichend\n\n\nKonkrete States m\u00fcssen f\u00fcr \nStateChange\n etwas zur\u00fcckgeben, das den n\u00e4chsten State identifiziert, z.B. den Typ (In State-machine Hashtable f\u00fcr die einzelnen konkreten States verwenden)\n\n\nn.b. das GoF-Sate Pattern definiert keinen solchen Mechanismus zum State-Switch\n\n\n\n\n\n\nWas, wenn ein konkreter State Daten der State-machine ver\u00e4ndern muss?\n\n\nHolder von Daten, der dem konkreten State \u00fcbergeben wird, z.B. \nincrement(timeHolder)\n bei Uhr\n\n\n\n\n\n\n\n\nMethods for States\n\n\n\n\nAlle Methoden (Implementation), die vorher in den States waren, kommen direkt in die State-Machine\n\n\nMethoden, die zum selben State geh\u00f6ren, werden in Function-Pointer-Lists zusammengefasst\n\n\nEine dynamische Struktur (z.B. Structs) wird mit Methoden abgef\u00fcllt, je eine Struktur pro State\n\n\nVorteil: \u00dcbersichtlicher f\u00fcr kleine Anwendungsf\u00e4lle\n\n\nNachteil: Grosse Klasse, viele Methoden\n\n\n\n\nCollections for States\n\n\n\n\nJeder State ist eine Collection in der State Machine\n\n\nIn den Collections k\u00f6nnen auch weitere State Machines sein\n\n\nbei jedem State change werden die Objekte in andere Collections verschoben\n\n\nLogik der State machine ist in einem \"Workpiece\"\n\n\nSimpelste Variante\n\n\n\n\nFrameworks\n\n\n\n\nFrameworks bieten \"Hooks\" f\u00fcr Erweiterungen\n\n\nIm Gegensatz zu einer Library steuert ein Framework den Kontrollfluss\n\n\nArbeiten mit Callbacks, Inversion of control\n\n\nApplication Frameworks sind oft over-engineered", 
            "title": "Beyond GoF"
        }, 
        {
            "location": "/apf/beyond_gof/#beyond-gof", 
            "text": "", 
            "title": "Beyond GoF"
        }, 
        {
            "location": "/apf/beyond_gof/#enumerator", 
            "text": "Probleme mit Iterator  Collections d\u00fcrfen nie w\u00e4hrend Iteration ver\u00e4ndert werden  Umgehung davon aufw\u00e4ndig, gibt enges coupling zwischen Iterator und Collection    GoF hat externer Iterator (\"klassisch\") und interner Iterator (= Enumerator) vermischt  Enumerator ist Inversion des Iterators  Collection hat selbst eine Methode, die ein Kommando entgegen nimmt  z.B.  c.forEach(i =  foo(i))    Iteration ist direkt in der Collection, dadurch hat es mehr Kontrolle, z.B. bei \u00c4nderungen w\u00e4hrend der Iteratation, oder mit Locking  Ohne Lambdas das Command-Pattern verwenden", 
            "title": "Enumerator"
        }, 
        {
            "location": "/apf/beyond_gof/#distribution", 
            "text": "Problem bei Remote Calls, wenn f\u00fcr jedes Element ein eigener Call auf das Remote-system gemacht werden muss  L\u00f6sung:  Batch Method  Pattern  Mehrere Elemente auf einmal schicken", 
            "title": "Distribution"
        }, 
        {
            "location": "/apf/beyond_gof/#state-pattern", 
            "text": "GoF-Beschreibung ist sehr allgemein, besserer Name w\u00e4re \"Objects for States\"  H\u00e4ufig overkill, oft ist auch ein primitives \"Flag-based\" State Management ausreichend  Konkrete States m\u00fcssen f\u00fcr  StateChange  etwas zur\u00fcckgeben, das den n\u00e4chsten State identifiziert, z.B. den Typ (In State-machine Hashtable f\u00fcr die einzelnen konkreten States verwenden)  n.b. das GoF-Sate Pattern definiert keinen solchen Mechanismus zum State-Switch    Was, wenn ein konkreter State Daten der State-machine ver\u00e4ndern muss?  Holder von Daten, der dem konkreten State \u00fcbergeben wird, z.B.  increment(timeHolder)  bei Uhr", 
            "title": "State Pattern"
        }, 
        {
            "location": "/apf/beyond_gof/#methods-for-states", 
            "text": "Alle Methoden (Implementation), die vorher in den States waren, kommen direkt in die State-Machine  Methoden, die zum selben State geh\u00f6ren, werden in Function-Pointer-Lists zusammengefasst  Eine dynamische Struktur (z.B. Structs) wird mit Methoden abgef\u00fcllt, je eine Struktur pro State  Vorteil: \u00dcbersichtlicher f\u00fcr kleine Anwendungsf\u00e4lle  Nachteil: Grosse Klasse, viele Methoden", 
            "title": "Methods for States"
        }, 
        {
            "location": "/apf/beyond_gof/#collections-for-states", 
            "text": "Jeder State ist eine Collection in der State Machine  In den Collections k\u00f6nnen auch weitere State Machines sein  bei jedem State change werden die Objekte in andere Collections verschoben  Logik der State machine ist in einem \"Workpiece\"  Simpelste Variante", 
            "title": "Collections for States"
        }, 
        {
            "location": "/apf/beyond_gof/#frameworks", 
            "text": "Frameworks bieten \"Hooks\" f\u00fcr Erweiterungen  Im Gegensatz zu einer Library steuert ein Framework den Kontrollfluss  Arbeiten mit Callbacks, Inversion of control  Application Frameworks sind oft over-engineered", 
            "title": "Frameworks"
        }, 
        {
            "location": "/apf/values/", 
            "text": "On the Value of Values\n\n\n\n\nIn C++ werden Objekte kopiert bei Parameter\u00fcbergabe (ausser es werden Referenzen \u00fcbergeben mit \n)\n\n\n\n\nDefinition M. Jackson\n\n\n\n\nEvents ist ein \"Individuum\", das zu einer bestimmten Zeit passiert\n\n\nz.B. Mausklick, Absenden einer Bestellung\n\n\n\n\n\n\nEntities sind Individuen, die \u00fcber eine Zeit lang existieren und Properties haben, die sich \u00e4ndern k\u00f6nnen\n\n\nBestellung, Datei, Profil, ...\n\n\n\n\n\n\nValues sind \"unantastbare\" Individuen, die sich nicht ver\u00e4ndern\n\n\nz.B. Zahlen, Farben, Zeichen, Koordinate\n\n\n\n\n\n\n\n\nDefinition Kevin Henney\n\n\n\n\nEntities m\u00fcssen unterschieden werden k\u00f6nnnen\n\n\nService: Objekte, die durch das Verhalten bestimmt sind (und nicht durch den Zustand)\n\n\nz.B. \nSystem.out\n, Connection-Services\n\n\n\n\n\n\nValue: Objekte sind durch Inhalt bestimmt, sie haben \nkeine relevante Identit\u00e4t\n\n\nz.B. Point, String, Integer\n\n\n\n\n\n\nTask: Im Gegensatz zum Service haben sie eine Identit\u00e4t und einen Zustand\n\n\nz.B. Runnables, Threads\n\n\n\n\n\n\n\n\nValues in Programming\n\n\n\n\nPure Functions k\u00f6nnen auch als values angesehen werden\n\n\nEinfach \u00fcbers Netzwerk zu \u00fcbertragen, weil sowieso nur Values \u00fcbertragen werden k\u00f6nnen\n\n\nDer Wert ist das wichtige, nicht die Identit\u00e4t\n\n\n\n\nOO-Example\n\n\n\n\nISBN als Typ modellieren, sonst muss das Format immer geparsed und gepr\u00fcft werden\n\n\nSo kann sich Format auch mal \u00e4ndern\n\n\n\n\nValue Objects\n\n\n\n\nZiel: Primitive Daten sinnvoll mit z.B. Einheiten repr\u00e4sentieren\n\n\nz.B. Datum\n\n\n\n\nJava\n\n\n\n\nEquals und Hashcode \u00fcberschreiben!\n\n\nAufpassen bei State-changes: Objekt klonen, damit nicht externe Referenzen gesetzt werden\n\n\nAlternative: Klasse immutable machen\n\n\n\n\n\n\n\n\nMutable Companion\n\n\n\n\nz.B. \nStringBuilder\n\n\nBuilder, der values zusammen baut", 
            "title": "Values"
        }, 
        {
            "location": "/apf/values/#on-the-value-of-values", 
            "text": "In C++ werden Objekte kopiert bei Parameter\u00fcbergabe (ausser es werden Referenzen \u00fcbergeben mit  )", 
            "title": "On the Value of Values"
        }, 
        {
            "location": "/apf/values/#definition-m-jackson", 
            "text": "Events ist ein \"Individuum\", das zu einer bestimmten Zeit passiert  z.B. Mausklick, Absenden einer Bestellung    Entities sind Individuen, die \u00fcber eine Zeit lang existieren und Properties haben, die sich \u00e4ndern k\u00f6nnen  Bestellung, Datei, Profil, ...    Values sind \"unantastbare\" Individuen, die sich nicht ver\u00e4ndern  z.B. Zahlen, Farben, Zeichen, Koordinate", 
            "title": "Definition M. Jackson"
        }, 
        {
            "location": "/apf/values/#definition-kevin-henney", 
            "text": "Entities m\u00fcssen unterschieden werden k\u00f6nnnen  Service: Objekte, die durch das Verhalten bestimmt sind (und nicht durch den Zustand)  z.B.  System.out , Connection-Services    Value: Objekte sind durch Inhalt bestimmt, sie haben  keine relevante Identit\u00e4t  z.B. Point, String, Integer    Task: Im Gegensatz zum Service haben sie eine Identit\u00e4t und einen Zustand  z.B. Runnables, Threads", 
            "title": "Definition Kevin Henney"
        }, 
        {
            "location": "/apf/values/#values-in-programming", 
            "text": "Pure Functions k\u00f6nnen auch als values angesehen werden  Einfach \u00fcbers Netzwerk zu \u00fcbertragen, weil sowieso nur Values \u00fcbertragen werden k\u00f6nnen  Der Wert ist das wichtige, nicht die Identit\u00e4t", 
            "title": "Values in Programming"
        }, 
        {
            "location": "/apf/values/#oo-example", 
            "text": "ISBN als Typ modellieren, sonst muss das Format immer geparsed und gepr\u00fcft werden  So kann sich Format auch mal \u00e4ndern", 
            "title": "OO-Example"
        }, 
        {
            "location": "/apf/values/#value-objects", 
            "text": "Ziel: Primitive Daten sinnvoll mit z.B. Einheiten repr\u00e4sentieren  z.B. Datum", 
            "title": "Value Objects"
        }, 
        {
            "location": "/apf/values/#java", 
            "text": "Equals und Hashcode \u00fcberschreiben!  Aufpassen bei State-changes: Objekt klonen, damit nicht externe Referenzen gesetzt werden  Alternative: Klasse immutable machen", 
            "title": "Java"
        }, 
        {
            "location": "/apf/values/#mutable-companion", 
            "text": "z.B.  StringBuilder  Builder, der values zusammen baut", 
            "title": "Mutable Companion"
        }, 
        {
            "location": "/apf/reflection/", 
            "text": "Reflection - Self-aware Software\n\n\nF\u00fcr was\n\n\n\n\nMocking/Test-Frameworks\n\n\nRemote Systems\n\n\nAnnotations\n\n\nOR-Mapper / z.B. EF\n\n\nException Handling (\n stack trace)\n\n\nDebugging\n\n\nPlugin-Systeme\n\n\nLinker / dynamisch (.so, .dll)\n\n\nDynamic Polymorphism\n\n\n\n\nReflection Pattern\n\n\n\n\nIm Base Level sind die normalen Objekte des Programms\n\n\nIm Meta Level sind die Informationen \u00fcber die Base level objekte, als Meta-Objects\n\n\nclass\n-Objekt in Java ist meta object\n\n\n\n\n\n\nMOP (Metaobject Protocol) ist ein interface f\u00fcr die meta objects\n\n\nz.B. \nObject.getClass()\n\n\n\n\n\n\nIntrospection: In Base Level Objects hinein \"schauen\"\n\n\neval\n z.B. ver\u00e4ndert Base Level Objects (intercession)\n\n\n\n\nType Object Pattern\n\n\n\n\nMeta-Object, das calls weiterleitet an ein konkretes Objekt, das von aussen gesetzt wird\n\n\nKonfiguration wird von extern, z.B. mit config-file eingespiesen\n\n\nNachteil: Keine inh\u00e4rente Type-Safety mehr\n\n\n\n\n\n\n\n\nProperty List\n\n\n\n\na.k.a Dictionary, Map\n\n\nProblem: z.B. variable Anzahl Parameter \u00fcbergeben (klassisch \n...varargs\n)\n\n\nL\u00f6sung: Property List \u00fcbergeben\n\n\nNachteile: \n\n\nNicht \"type-safe\"\n\n\nEs k\u00f6nnen beliebig viele Elemente in der Property List sein\n\n\nAttribut-Namen werden nicht von Compiler gepr\u00fcft\n\n\nMemory Management (Garbage Collection?)\n\n\n\n\n\n\n\n\nAnything\n\n\n\n\nRekursive Struktur von Anything-Objekten\n\n\nJedes Element ist entweder \"etwas\" oder eine Liste von \"etwas\" (oder dictionary)\n\n\n\n\n\n\nHeute \"JSON\"\n\n\nMeist f\u00fcr Konfigurationen verwendet\n\n\n\"Anything\" in \"Anything\" mit Composite-Pattern\n\n\nAchtung: Unterschied Composite / Decorator ist nur Assoziation zu Base-Klasse!\nr\n\n\n\n\n\n\n\n\nExtension Interface\n\n\n\n\nQuasi Plugin-Pattern\n\n\nComponent Factory\n instanziiert und verwaltet die Komponenten\n\n\nClient fragt \nComponent Factory\n nach bestimmter Komponenten und bekommt ein Interface zur\u00fcck\n\n\nz.B. Eclipse: Client ben\u00f6tigt C++ Editor\n\n\nBraucht Reflection, um zur Laufzeit die entsprechenden Komponenten zu finden\n\n\n\n\nZusammenfassung\n\n\n\n\nReflection braucht immer overhead durch Runtime\n\n\nBehindert Optimierung (JIT)\n\n\nKontrollfluss kann komplex sein\n\n\nKann sehr n\u00fctzlich sein f\u00fcr sich entwickelnde Systeme\n\n\nKorrektheit ist nicht mehr nachweisbar", 
            "title": "Reflection"
        }, 
        {
            "location": "/apf/reflection/#reflection-self-aware-software", 
            "text": "", 
            "title": "Reflection - Self-aware Software"
        }, 
        {
            "location": "/apf/reflection/#fur-was", 
            "text": "Mocking/Test-Frameworks  Remote Systems  Annotations  OR-Mapper / z.B. EF  Exception Handling (  stack trace)  Debugging  Plugin-Systeme  Linker / dynamisch (.so, .dll)  Dynamic Polymorphism", 
            "title": "F\u00fcr was"
        }, 
        {
            "location": "/apf/reflection/#reflection-pattern", 
            "text": "Im Base Level sind die normalen Objekte des Programms  Im Meta Level sind die Informationen \u00fcber die Base level objekte, als Meta-Objects  class -Objekt in Java ist meta object    MOP (Metaobject Protocol) ist ein interface f\u00fcr die meta objects  z.B.  Object.getClass()    Introspection: In Base Level Objects hinein \"schauen\"  eval  z.B. ver\u00e4ndert Base Level Objects (intercession)", 
            "title": "Reflection Pattern"
        }, 
        {
            "location": "/apf/reflection/#type-object-pattern", 
            "text": "Meta-Object, das calls weiterleitet an ein konkretes Objekt, das von aussen gesetzt wird  Konfiguration wird von extern, z.B. mit config-file eingespiesen  Nachteil: Keine inh\u00e4rente Type-Safety mehr", 
            "title": "Type Object Pattern"
        }, 
        {
            "location": "/apf/reflection/#property-list", 
            "text": "a.k.a Dictionary, Map  Problem: z.B. variable Anzahl Parameter \u00fcbergeben (klassisch  ...varargs )  L\u00f6sung: Property List \u00fcbergeben  Nachteile:   Nicht \"type-safe\"  Es k\u00f6nnen beliebig viele Elemente in der Property List sein  Attribut-Namen werden nicht von Compiler gepr\u00fcft  Memory Management (Garbage Collection?)", 
            "title": "Property List"
        }, 
        {
            "location": "/apf/reflection/#anything", 
            "text": "Rekursive Struktur von Anything-Objekten  Jedes Element ist entweder \"etwas\" oder eine Liste von \"etwas\" (oder dictionary)    Heute \"JSON\"  Meist f\u00fcr Konfigurationen verwendet  \"Anything\" in \"Anything\" mit Composite-Pattern  Achtung: Unterschied Composite / Decorator ist nur Assoziation zu Base-Klasse!\nr", 
            "title": "Anything"
        }, 
        {
            "location": "/apf/reflection/#extension-interface", 
            "text": "Quasi Plugin-Pattern  Component Factory  instanziiert und verwaltet die Komponenten  Client fragt  Component Factory  nach bestimmter Komponenten und bekommt ein Interface zur\u00fcck  z.B. Eclipse: Client ben\u00f6tigt C++ Editor  Braucht Reflection, um zur Laufzeit die entsprechenden Komponenten zu finden", 
            "title": "Extension Interface"
        }, 
        {
            "location": "/apf/reflection/#zusammenfassung", 
            "text": "Reflection braucht immer overhead durch Runtime  Behindert Optimierung (JIT)  Kontrollfluss kann komplex sein  Kann sehr n\u00fctzlich sein f\u00fcr sich entwickelnde Systeme  Korrektheit ist nicht mehr nachweisbar", 
            "title": "Zusammenfassung"
        }, 
        {
            "location": "/apf/junit_dissection/", 
            "text": "Testing Framework Dissection\n\n\nJUnit Design\n\n\n\n\nCommand-Pattern f\u00fcr Tests\n\n\nJeder \nTestCase\n implementiert das Command-Interface \nTest\n\n\nTestCase\n hat \nrun()\n als Template-Method\n\n\nBesteht aus setup, run und teardown als \"hooks\"\n\n\n\n\n\n\nTDD Exkurs: \nZOMBIES\n\n\n\"Zero, One, Many, Behavior Interface, Exceptional Behavior, Simple Scenario / Simple Solution\"\n\n\n\n\n\n\nResultate sammeln mit \nCollecting Parameter\n\n\nFactory Method kommt oft in Template Method vor\n\n\nExceptions werden in TestResult gesammelt\n\n\nF\u00fcr jede Test-Methode wird mit Reflection ein Adapter zum TestCase erstellt\n\n\nViele Test-Cases werden in einer suite gruppiert und mit \nComposite\n ineinander verschachtelt\n\n\n\n\nExtending JUnit\n\n\n\n\nMit Decorator z.B. Timing implementieren\n\n\n\n\nJUTLAND\n\n\n\n\nTodo\n\n\nKevlin Henney's JAOOO Presentation\n\n\n\n\n\n\nMehr als Design-\u00dcbung gemacht\n\n\nTester\n ist \"Nanokernel\" (Micro-Kernel)\n\n\nPolicies definieren Tests\n\n\nTest-Listeners reagieren auf Resultate\n\n\n\n\nFIT\n\n\n\n\nFramework for Integrated Test (von Cunningham)\n\n\nDeklarativ: Was muss Programm k\u00f6nnen?\n\n\nHTML-Tabellen als Input, die Tests spezifizieren\n\n\nSehr schlank mit nur 3 Klassen", 
            "title": "JUnit Dissection"
        }, 
        {
            "location": "/apf/junit_dissection/#testing-framework-dissection", 
            "text": "", 
            "title": "Testing Framework Dissection"
        }, 
        {
            "location": "/apf/junit_dissection/#junit-design", 
            "text": "Command-Pattern f\u00fcr Tests  Jeder  TestCase  implementiert das Command-Interface  Test  TestCase  hat  run()  als Template-Method  Besteht aus setup, run und teardown als \"hooks\"    TDD Exkurs:  ZOMBIES  \"Zero, One, Many, Behavior Interface, Exceptional Behavior, Simple Scenario / Simple Solution\"    Resultate sammeln mit  Collecting Parameter  Factory Method kommt oft in Template Method vor  Exceptions werden in TestResult gesammelt  F\u00fcr jede Test-Methode wird mit Reflection ein Adapter zum TestCase erstellt  Viele Test-Cases werden in einer suite gruppiert und mit  Composite  ineinander verschachtelt", 
            "title": "JUnit Design"
        }, 
        {
            "location": "/apf/junit_dissection/#extending-junit", 
            "text": "Mit Decorator z.B. Timing implementieren", 
            "title": "Extending JUnit"
        }, 
        {
            "location": "/apf/junit_dissection/#jutland", 
            "text": "Todo  Kevlin Henney's JAOOO Presentation    Mehr als Design-\u00dcbung gemacht  Tester  ist \"Nanokernel\" (Micro-Kernel)  Policies definieren Tests  Test-Listeners reagieren auf Resultate", 
            "title": "JUTLAND"
        }, 
        {
            "location": "/apf/junit_dissection/#fit", 
            "text": "Framework for Integrated Test (von Cunningham)  Deklarativ: Was muss Programm k\u00f6nnen?  HTML-Tabellen als Input, die Tests spezifizieren  Sehr schlank mit nur 3 Klassen", 
            "title": "FIT"
        }, 
        {
            "location": "/apf/wam/", 
            "text": "WAM Framework Construction\n\n\n\n\nWAM: Werkzeug, Automat, Material\n\n\nBilden die zentralen Metaphern\n\n\n\n\n\n\nMethodik, um Frameworks zu modellieren\n\n\n\n\nAnwendungsbereich\n\n\n\n\n\"Sachbearbeiter\": Arbeitsfluss nicht strikt vorgegeben\n\n\nMensch braucht Kontrolle \u00fcber Abl\u00e4ufe - Freiheit und Flexibilit\u00e4t notwendig\n\n\nRascher Wandel der Anforderungen\n\n\nSoftware muss flexibel erweiterbar sein", 
            "title": "WAM"
        }, 
        {
            "location": "/apf/wam/#wam-framework-construction", 
            "text": "WAM: Werkzeug, Automat, Material  Bilden die zentralen Metaphern    Methodik, um Frameworks zu modellieren", 
            "title": "WAM Framework Construction"
        }, 
        {
            "location": "/apf/wam/#anwendungsbereich", 
            "text": "\"Sachbearbeiter\": Arbeitsfluss nicht strikt vorgegeben  Mensch braucht Kontrolle \u00fcber Abl\u00e4ufe - Freiheit und Flexibilit\u00e4t notwendig  Rascher Wandel der Anforderungen  Software muss flexibel erweiterbar sein", 
            "title": "Anwendungsbereich"
        }, 
        {
            "location": "/apf/eclipse_architecture/", 
            "text": "Eclipse Architecture and Patterns\n\n\n\u00dcberblick\n\n\n\n\nWurde zuerst als Framework f\u00fcr IDEs entwickelt\n\n\nDann mit dem Ziel, eine Software-Plattform f\u00fcr allgemeine Desktop-Applikationen zu sein\n\n\nFast alles ist als Plugin implementiert - auch der Workbench (das GUI)\n\n\n\n\nSWT / JFace\n\n\n\n\nPlattformunabh\u00e4ngig, aber Teil des GUIs ist aber plattform-spezifisch\n\n\nSWT selbst entwickelt\n\n\nD\u00fcnne Abstraktionsschicht \u00fcber das GUI des Betriebssystems\n\n\n\n\n\n\nJFace baut auf SWT auf und bildet die konkreten und komplexeren GUI-Komponenten\n\n\n\n\nOSGi\n\n\n\n\nOpen Services Gateway initiative\n\n\nKomponenten- und Service-Modell f\u00fcr Java + Dependency Management\n\n\nKomponenten k\u00f6nnen geb\u00fcndelt werden und dynamisch starten / stoppen\n\n\n\u00e4hnlich zu Java 9 Modularisierung\n\n\nStandard, der von Eclipse implementiert wird (mit Equinox)\n\n\n\n\nEclipse Plug-ins\n\n\n\n\nEclipse Plugins sind OSGi bundles\n\n\nPlugins k\u00f6nnen nicht ohne Neustart installiert werden, weil OSGi Services nicht benutzt werden\n\n\nJedes Plugin hat eigenen Class loader, womit mehrere Plugins auch unterschiedliche Versionen einer dependency benutzen k\u00f6nnen\n\n\nPlugins werden erst geladen, wenn es ben\u00f6tigt wird\n\n\nEclipse kann statische XML-Files durchsuchen, ohne daf\u00fcr Java Code zu laden\n\n\n\n\n\n\n\n\nExtension Points\n\n\n\n\nBsp: Plugin m\u00f6chte sich in ein Men\u00fc einh\u00e4ngen\n\n\nMen\u00fc bietet einen Extension Point an\n\n\nPlugin implementiert Interface des Extension Points\n\n\n\n\n\n\nPlugins k\u00f6nnen selbst EPs zur Verf\u00fcgung stellen\n\n\nWird definiert in \nplugin.xml\n\n\n\n\nEclipse Core Patterns\n\n\n\n\nViele Singletons - Unit testing unm\u00f6glich, ohne eigene Instanz zu starten\n\n\nProxy Pattern: Handler f\u00fcr eine Ressource anbieten, als Abstraktion auf das OS\n\n\nWird auch genutzt f\u00fcr Plugin Lazy Loading\n\n\nPlugin wird erst geladen, wenn der Proxy die \"action\" bekommt\n\n\n\n\n\n\nPluggable Adapter: Komplexe Komponenten in JFace\n\n\nObserver z.B. auf Ressourcen\n\n\nStrategy: Ein Teil eines Controls kann verschiedene Arten von Layouts (=Strategies) haben\n\n\nCommand: JFace Action, z.B. bei einem Klick auf ein Men\u00fc\n\n\n\n\nRefactoring Language Toolkit (LTK)\n\n\n\n\nSprach-unabh\u00e4ngige API f\u00fcr Refactorings\n\n\nTemplate Method, um Skeleton vorzugeben und bestimmte Schritte an Unterklassen weiter zu geben\n\n\nAm Endes des Refactorings wird ein \nChange\n Objekt erstellt, das vom Eclipse auf die Files angewendet wird\n\n\nEin Change kann aus mehreren Komponenten bestehen -\n \nComposite Pattern\n\n\nRefactorings k\u00f6nnen aus der History exportiert werden, daf\u00fcr werden sie serialisiert -\n \nMemento Pattern\n\n\nRefactorings arbeiten mit dem AST\n\n\nUm AST zu traversieren -\n \nVisitor Pattern\n\n\nTraversierung ist in den Knoten selbst, nur die ben\u00f6tigten Methoden werden implementiert", 
            "title": "Eclipse Architecture"
        }, 
        {
            "location": "/apf/eclipse_architecture/#eclipse-architecture-and-patterns", 
            "text": "", 
            "title": "Eclipse Architecture and Patterns"
        }, 
        {
            "location": "/apf/eclipse_architecture/#uberblick", 
            "text": "Wurde zuerst als Framework f\u00fcr IDEs entwickelt  Dann mit dem Ziel, eine Software-Plattform f\u00fcr allgemeine Desktop-Applikationen zu sein  Fast alles ist als Plugin implementiert - auch der Workbench (das GUI)", 
            "title": "\u00dcberblick"
        }, 
        {
            "location": "/apf/eclipse_architecture/#swt-jface", 
            "text": "Plattformunabh\u00e4ngig, aber Teil des GUIs ist aber plattform-spezifisch  SWT selbst entwickelt  D\u00fcnne Abstraktionsschicht \u00fcber das GUI des Betriebssystems    JFace baut auf SWT auf und bildet die konkreten und komplexeren GUI-Komponenten", 
            "title": "SWT / JFace"
        }, 
        {
            "location": "/apf/eclipse_architecture/#osgi", 
            "text": "Open Services Gateway initiative  Komponenten- und Service-Modell f\u00fcr Java + Dependency Management  Komponenten k\u00f6nnen geb\u00fcndelt werden und dynamisch starten / stoppen  \u00e4hnlich zu Java 9 Modularisierung  Standard, der von Eclipse implementiert wird (mit Equinox)", 
            "title": "OSGi"
        }, 
        {
            "location": "/apf/eclipse_architecture/#eclipse-plug-ins", 
            "text": "Eclipse Plugins sind OSGi bundles  Plugins k\u00f6nnen nicht ohne Neustart installiert werden, weil OSGi Services nicht benutzt werden  Jedes Plugin hat eigenen Class loader, womit mehrere Plugins auch unterschiedliche Versionen einer dependency benutzen k\u00f6nnen  Plugins werden erst geladen, wenn es ben\u00f6tigt wird  Eclipse kann statische XML-Files durchsuchen, ohne daf\u00fcr Java Code zu laden", 
            "title": "Eclipse Plug-ins"
        }, 
        {
            "location": "/apf/eclipse_architecture/#extension-points", 
            "text": "Bsp: Plugin m\u00f6chte sich in ein Men\u00fc einh\u00e4ngen  Men\u00fc bietet einen Extension Point an  Plugin implementiert Interface des Extension Points    Plugins k\u00f6nnen selbst EPs zur Verf\u00fcgung stellen  Wird definiert in  plugin.xml", 
            "title": "Extension Points"
        }, 
        {
            "location": "/apf/eclipse_architecture/#eclipse-core-patterns", 
            "text": "Viele Singletons - Unit testing unm\u00f6glich, ohne eigene Instanz zu starten  Proxy Pattern: Handler f\u00fcr eine Ressource anbieten, als Abstraktion auf das OS  Wird auch genutzt f\u00fcr Plugin Lazy Loading  Plugin wird erst geladen, wenn der Proxy die \"action\" bekommt    Pluggable Adapter: Komplexe Komponenten in JFace  Observer z.B. auf Ressourcen  Strategy: Ein Teil eines Controls kann verschiedene Arten von Layouts (=Strategies) haben  Command: JFace Action, z.B. bei einem Klick auf ein Men\u00fc", 
            "title": "Eclipse Core Patterns"
        }, 
        {
            "location": "/apf/eclipse_architecture/#refactoring-language-toolkit-ltk", 
            "text": "Sprach-unabh\u00e4ngige API f\u00fcr Refactorings  Template Method, um Skeleton vorzugeben und bestimmte Schritte an Unterklassen weiter zu geben  Am Endes des Refactorings wird ein  Change  Objekt erstellt, das vom Eclipse auf die Files angewendet wird  Ein Change kann aus mehreren Komponenten bestehen -   Composite Pattern  Refactorings k\u00f6nnen aus der History exportiert werden, daf\u00fcr werden sie serialisiert -   Memento Pattern  Refactorings arbeiten mit dem AST  Um AST zu traversieren -   Visitor Pattern  Traversierung ist in den Knoten selbst, nur die ben\u00f6tigten Methoden werden implementiert", 
            "title": "Refactoring Language Toolkit (LTK)"
        }, 
        {
            "location": "/apf/ppp/", 
            "text": "Patterns for Parallel Programming\n\n\nHardware Architektur\n\n\n\n\nPentium konnte Berechnungen parallel auf floating-point unit und integer unit ausf\u00fchren\n\n\nIntel i / xeon CPU's haben Vector Registers, um Vektoren im einen Schritt zu berechnen\n\n\n\n\n\n\nInfo\n\n\nhttps://godbolt.org/\n als Compiler Explorer\n\n\n\n\nDecomposing Strategy\n\n\n\n\nZiel: Ein Problem in kleinere zerteilen, um diese zu parallelisieren\n\n\nAnsatz \nTask decomposition\n: Problem in Tasks zerlegen\n\n\nz.B. unabh\u00e4ngige Requests verarbeiten\n\n\n\n\n\n\nAnsatz \nData decomposition\n: Daten zerlegen\n\n\nz.B. in Physik, Raum in kleine unabh\u00e4ngige Teile zu teilen\n\n\n\n\n\n\nBeide Ans\u00e4tze k\u00f6nnen kombiniert eingesetzt werden\n\n\nSchwierigkeit: Abh\u00e4ngigkeiten (die nicht offensichtlich sind)\n\n\nloop-splitting: Unabh\u00e4ngige Iterationen parallelisieren\n\n\n\n\nKoordination\n\n\n\n\nlinear Abh\u00e4ngige Tasks: Pipes and Filters\n\n\n\"ungeordnete\" Abh\u00e4ngigkeiten: Event-based coordination, analog Thread Pools", 
            "title": "Parallel Programming Patterns"
        }, 
        {
            "location": "/apf/ppp/#patterns-for-parallel-programming", 
            "text": "", 
            "title": "Patterns for Parallel Programming"
        }, 
        {
            "location": "/apf/ppp/#hardware-architektur", 
            "text": "Pentium konnte Berechnungen parallel auf floating-point unit und integer unit ausf\u00fchren  Intel i / xeon CPU's haben Vector Registers, um Vektoren im einen Schritt zu berechnen    Info  https://godbolt.org/  als Compiler Explorer", 
            "title": "Hardware Architektur"
        }, 
        {
            "location": "/apf/ppp/#decomposing-strategy", 
            "text": "Ziel: Ein Problem in kleinere zerteilen, um diese zu parallelisieren  Ansatz  Task decomposition : Problem in Tasks zerlegen  z.B. unabh\u00e4ngige Requests verarbeiten    Ansatz  Data decomposition : Daten zerlegen  z.B. in Physik, Raum in kleine unabh\u00e4ngige Teile zu teilen    Beide Ans\u00e4tze k\u00f6nnen kombiniert eingesetzt werden  Schwierigkeit: Abh\u00e4ngigkeiten (die nicht offensichtlich sind)  loop-splitting: Unabh\u00e4ngige Iterationen parallelisieren", 
            "title": "Decomposing Strategy"
        }, 
        {
            "location": "/apf/ppp/#koordination", 
            "text": "linear Abh\u00e4ngige Tasks: Pipes and Filters  \"ungeordnete\" Abh\u00e4ngigkeiten: Event-based coordination, analog Thread Pools", 
            "title": "Koordination"
        }, 
        {
            "location": "/apf/flyweight_singleton/", 
            "text": "Flyweight Boxing \n Singleton Assassination\n\n\nFlyweight\n\n\n\n\n\"Most state can be made extrinsic\": Wenn Zustand ausgelagert wird, sind die Flyweights leer, dadurch bringt es nicht viel\n\n\nFactory ist eigentlich der Manager der Flyweights\n\n\nUnsharedConcreteFlgyweight\n ist verwirrend und geh\u00f6rt eigentlich nicht zum Pattern\n\n\nFlyweight zeigt eigentlich mehrere Patterns\n\n\nFactory Method als Teil eines Managers\n\n\nImmutable Value\n\n\nPooling\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nFactory Method wird oft als Hook in einem Template Method Pattern verwendet\n\n\n\n\n\n\nTodo\n\n\nManager Design Pattern (Selbststudium) lesen\n\n\n\n\n\n\nInfo\n\n\nValue objects in Java: \nfinal\n fields \u00fcber Konstruktor setzen. Achtung vor Referenzen, \nfinal\n ist nicht transitiv wie in C++!\n\n\n\n\nConsequences\n\n\n\n\nLaufzeitkosten, vor allem heute relevant, da eigentlich alles gecached werden kann und nicht von einem zentralen Pool geholt werden muss\n\n\nDaf\u00fcr spart es Speicherplatz\n\n\n\n\nPattern Kombinationen\n\n\n\n\nTemplate Method -\n Factory Method\n\n\nComposite -\n Chain or Responsibility\n\n\n\n\nSingleton\n\n\n\n\nShared Resource, die nicht immutable ist -\n Problem!\n\n\nKann \nmaximal\n einmal instanziiert werden, also auch gar nicht (zur Optimierung)\n\n\nSingleton vererben: Superklasse muss Subklasse kennen, damit die Instanz erstellt werden kann\n\n\nGibt zirkul\u00e4re Abh\u00e4ngigkeit!\n\n\n\n\n\n\nGoF-Buch beschreibt keine Nachteile!\n\n\nDouble-Checked-Locking: Zuerst ohne Lock checken, ob die Instanz existiert, und erst dann wird gelockt (mit 2. Check)\n\n\nMonostate Pattern\n\n\nEs gibt nur einen State \u00fcber alle Instanzen\n\n\nKlasse wird mit \nstatic\n fields geschrieben, die von non-static-methoden zugegriffen werden\n\n\n\n\n\n\nAlternative: Parameterize from above, bzw. Dependency Injection\n\n\n\n\n\n\nQuote\n\n\n\"How do you provide global variables in languages without global variables? Don't. Your programs will thank you for taking the time to think about design instead.\" - Kent Beck", 
            "title": "Flyweight Boxing / Singleton Assasination"
        }, 
        {
            "location": "/apf/flyweight_singleton/#flyweight-boxing-singleton-assassination", 
            "text": "", 
            "title": "Flyweight Boxing &amp; Singleton Assassination"
        }, 
        {
            "location": "/apf/flyweight_singleton/#flyweight", 
            "text": "\"Most state can be made extrinsic\": Wenn Zustand ausgelagert wird, sind die Flyweights leer, dadurch bringt es nicht viel  Factory ist eigentlich der Manager der Flyweights  UnsharedConcreteFlgyweight  ist verwirrend und geh\u00f6rt eigentlich nicht zum Pattern  Flyweight zeigt eigentlich mehrere Patterns  Factory Method als Teil eines Managers  Immutable Value  Pooling      Info  Factory Method wird oft als Hook in einem Template Method Pattern verwendet    Todo  Manager Design Pattern (Selbststudium) lesen    Info  Value objects in Java:  final  fields \u00fcber Konstruktor setzen. Achtung vor Referenzen,  final  ist nicht transitiv wie in C++!", 
            "title": "Flyweight"
        }, 
        {
            "location": "/apf/flyweight_singleton/#consequences", 
            "text": "Laufzeitkosten, vor allem heute relevant, da eigentlich alles gecached werden kann und nicht von einem zentralen Pool geholt werden muss  Daf\u00fcr spart es Speicherplatz", 
            "title": "Consequences"
        }, 
        {
            "location": "/apf/flyweight_singleton/#pattern-kombinationen", 
            "text": "Template Method -  Factory Method  Composite -  Chain or Responsibility", 
            "title": "Pattern Kombinationen"
        }, 
        {
            "location": "/apf/flyweight_singleton/#singleton", 
            "text": "Shared Resource, die nicht immutable ist -  Problem!  Kann  maximal  einmal instanziiert werden, also auch gar nicht (zur Optimierung)  Singleton vererben: Superklasse muss Subklasse kennen, damit die Instanz erstellt werden kann  Gibt zirkul\u00e4re Abh\u00e4ngigkeit!    GoF-Buch beschreibt keine Nachteile!  Double-Checked-Locking: Zuerst ohne Lock checken, ob die Instanz existiert, und erst dann wird gelockt (mit 2. Check)  Monostate Pattern  Es gibt nur einen State \u00fcber alle Instanzen  Klasse wird mit  static  fields geschrieben, die von non-static-methoden zugegriffen werden    Alternative: Parameterize from above, bzw. Dependency Injection    Quote  \"How do you provide global variables in languages without global variables? Don't. Your programs will thank you for taking the time to think about design instead.\" - Kent Beck", 
            "title": "Singleton"
        }
    ]
}